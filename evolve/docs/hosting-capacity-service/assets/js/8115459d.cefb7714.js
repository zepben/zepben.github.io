"use strict";(self.webpackChunkhosting_capacity_service=self.webpackChunkhosting_capacity_service||[]).push([["9131"],{6642:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>d,toc:()=>o,default:()=>h,metadata:()=>r,assets:()=>a,contentTitle:()=>l});var r=JSON.parse('{"id":"how-to-guides/configuration","title":"Configuration","description":"Model Processor Configuration","source":"@site/versioned_docs/version-0.5.1/how-to-guides/configuration.mdx","sourceDirName":"how-to-guides","slug":"/how-to-guides/configuration","permalink":"/evolve/docs/hosting-capacity-service/0.5.1/how-to-guides/configuration","draft":false,"unlisted":false,"tags":[],"version":"0.5.1","frontMatter":{"id":"configuration","title":"Configuration","slug":"/how-to-guides/configuration","hide_table_of_contents":true},"sidebar":"theSidebar","previous":{"title":"How to run a work package","permalink":"/evolve/docs/hosting-capacity-service/0.5.1/how-to-guides/run-a-work-package"},"next":{"title":"How to install Python","permalink":"/evolve/docs/hosting-capacity-service/0.5.1/how-to-guides/install-python"}}'),s=n(4848),i=n(4429);let d={id:"configuration",title:"Configuration",slug:"/how-to-guides/configuration",hide_table_of_contents:!0},l,a={},o=[{value:"Model Processor Configuration",id:"model-processor-configuration",level:3},{value:"Common Config",id:"common-config",level:3},{value:"Generator Config",id:"generator-config",level:3},{value:"ResultProcessor Config",id:"resultprocessor-config",level:3}];function c(e){let t={code:"code",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h3,{id:"model-processor-configuration",children:"Model Processor Configuration"}),"\n",(0,s.jsx)(t.p,{children:"There are various elements that must be configures to sucessfully create a OpenDSS model from the input data, which are then used to run a Hosting Capacity Model work package."}),"\n",(0,s.jsx)(t.p,{children:"Configs can be set up through config file or by hard coding in the variables"}),"\n",(0,s.jsx)(t.p,{children:"Here is a simple example that refers to external config files."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'forecast_config = ForecastConfig(\n    feeders=config["feeders"],\n    years=config["forecast_years"],\n    scenarios=config["scenarios"],\n    load_time=TimePeriod(\n        start_time=datetime.fromisoformat(config["load_time"]["start1"]),\n        end_time=datetime.fromisoformat(config["load_time"]["end1"]),\n    )\n)\n'})}),"\n",(0,s.jsx)(t.p,{children:"Configs"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'    feeder_configs = FeederConfigs(\n      configs=[\n        FeederConfig(\n          feeder=config["feeders"][0],\n          years=config["forecast_years"],\n          scenarios=config["scenarios"],\n          load_time=TimePeriod(\n            start_time=datetime.fromisoformat(config["load_time"]["start2"]),\n            end_time=datetime.fromisoformat(config["load_time"]["end2"]),\n            load_overrides={\n              "nmi1": TimePeriodLoadOverride(\n                # Override profile needs to have entries covering a single day or a year.\n                load_watts=[\n                  1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0,\n                  13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0\n                ],\n                # Amount of entry between watts and var must match if both watts and vars exists.\n                load_var=[\n                  2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0,\n                  14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0\n                ],\n                gen_var=None,\n                gen_watts=None\n              )\n            }\n          )\n        ),\n        # Fixed time example\n        FeederConfig(\n          feeder=config["feeders"][1],\n          years=config["forecast_years"],\n          scenarios=config["scenarios"],\n          load_time=FixedTime(\n            time=datetime.fromisoformat(config["load_time"]["start1"]),\n            load_overrides={\n              "nmi2": FixedTimeLoadOverride(\n                # Fixed time load override supports any number of entries.\n                load_watts=[1.0, 2.0, 3.0],\n                # Same matching entry logic applies here when both watts and var exists.\n                load_var=[2.0, 3.0, 4.0],\n                gen_var=None,\n                gen_watts=None\n              )\n            }\n          )\n        )\n      ]\n    )\n    )\n'})}),"\n",(0,s.jsx)(t.h3,{id:"common-config",children:"Common Config"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Value"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description and Defaults"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"timezone"}),(0,s.jsx)(t.td,{children:"TimeZone"}),(0,s.jsx)(t.td,{children:'the timezone the load data is is, for example, NEM time, eg "GMT+10"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"startTime"}),(0,s.jsx)(t.td,{children:"Instant"}),(0,s.jsx)(t.td,{children:"The datetime where the data starts, such as \"2022-04-01T00:00:00+10\". The data is interval ending, such that 00:01:00 represents data from 12:30am to 1am. The timezone in the startTime and endTime value, represented by the '+X' at the end of the value, AND the timezone variable itself, must be present, and must match, to avoid model issues."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"endTime"}),(0,s.jsx)(t.td,{children:"Instant"}),(0,s.jsx)(t.td,{children:"The datetime where the data ends, such as \"2023-04-01T00:00:00+10\". The data is interval ending, such that 00:01:00 represents data from 12:30am to 1am. The timezone in the startTime and endTime value, represented by the '+X' at the end of the value, AND the timezone variable itself, must be present, and must match, to avoid model issues."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fixedTime"}),(0,s.jsx)(t.td,{children:"Instant"}),(0,s.jsx)(t.td,{children:"Load time instant when generating a fixed time model. Cannot have both a fixed time and a start/end time, must be either a start/end time or a fixed time."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"qualityAssuranceProcessing"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"This value can be true or false. If true, extra reporting is enabled in the openDSS model. More TODO"})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"generator-config",children:"Generator Config"}),"\n",(0,s.jsx)(t.p,{children:"Including Model, Solve, and Raw Results"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Value"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description and Defaults"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"pFactorBaseExports"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Power factor to set for base model Generators during model translation. If null the model will use the reactive power specified in the load profiles. NOTE: If set, it will override all reactive power in the input data with this value."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"pFactorBaseImports"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Power factor to set for base model Loads during model translation. If null the model will use the reactive power specified in the load profiles. NOTE: If set, it will override all reactive power in the input data with this value."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"pFactorForecastPv"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Power factor to set for scenario (forecast) model Generators during model translation."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fixSinglePhaseLoads"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"if true, enables the maxSinglePhaseLoad value and thus changes to the model as described. If false, no changes are made to the model"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxSinglePhaseLoad"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Value in Watt. The single phase load fixer finds consumers that have a peak load (within the modelled time period) greater than a configured value (default 30000W), and upgrades them to three-phase loads. The intent is to correct data inaccuracies where the number of phases reported for a consumer appears to be incorrect. By default, we expect a 30kW load would not appear on a single phase consumer, so we upgrade them to three-phase. This consists of tracing upstream to the distribution transformer and spreading 3 phases (ABCN) back to the transformer where possible."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxLoadLvLineRatio"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"This value is the ratio that a line in the LV network can be over its nominal capacity before it is automatically upgraded. The intent is to find LV lines that have unrealistically low current ratings which would stop convergence, and upgrade them to sensible ratings. When a conductors rating is upgraded, we also then upgrade the impedances to a type in line with the new rating, utilising a pre-configured catalogue of rating and impedance data, and matching the phase configuration of the consumer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxLoadServiceLineRatio"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"This value is the ratio that a service line in can be over its nominal capacity before it is automatically upgraded. The intent is to find service lines that have unrealistically low current ratings which would stop convergence, and upgrade them to sensible ratings. When a conductors rating is upgraded, we also then upgrade the impedances to a type in line with the new rating, utilising a pre-configured catalogue of rating and impedance data, and matching the phase configuration of the consumer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxLoadTxRatio"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"The overloading consumer fixer finds consumers that have peak load (within the modelled time period) greater than the capacity of the transformer they are attached to by a configurable ratio, and then reconfigures them to be HV consumers (attached above the transformer). The aim is to identify HV consumers that have been incorrectly connected as LV consumers, and resolve this connectivity."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxGenTxRatio"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"The overloading consumer fixer finds consumers that have peak generation (within the modelled time period) greater than the capacity of the transformer they are attached to by a configurable ratio, and then reconfigures them to be HV consumers (attached above the transformer). The aim is to identify HV consumers that have been incorrectly connected as LV consumers, and resolve this connectivity."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fixOverloadingConsumers"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"this enables the 'maxLoadTxRatio' and 'maxGenTxRatio' fixes."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fixUndersizedServiceLines"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"this enables the 'maxLoadLvLineRatio' and 'maxLoadServiceLineRatio' fixes."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feederScenarioAllocationStrategy"}),(0,s.jsx)(t.td,{children:"ADDITIVE or RANDOM"}),(0,s.jsx)(t.td,{children:"Strategy for scenario ev, pv and bess allocation. ADDITIVE will be each year is built upon the last year's allocation, while RANDOM will be a different allocation every year."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVRegEnabled"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"Create models with a Closed Loop Voltage Regulator at the Zone sub. If false, existing voltage regulator's in the zone sub will be used."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feederHead"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"controls whether to place a meter at the voltage source at the feeder head."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"distTransformers"}),(0,s.jsx)(t.td,{children:"boolean"}),(0,s.jsx)(t.td,{children:"controls hether to place a meter at the secondary winding of each distribution transformer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energyConsumerMeterGroup"}),(0,s.jsx)(t.td,{children:"String"}),(0,s.jsx)(t.td,{children:"The ID of the meter group to use for populating EnergyMeters at EnergyConsumers. Can be null"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"meterSwitchClass"}),(0,s.jsx)(t.td,{children:"SwitchClass"}),(0,s.jsx)(t.td,{children:"Specifies which switch classes to place meters at, and the regex pattern to match for in the switch names. Option are BREAKER, DISCONNECTOR, FUSE, JUMPER,\xa0 LOAD_BREAK_SWITCH, RECLOSER)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"namePattern"}),(0,s.jsx)(t.td,{children:"String"}),(0,s.jsx)(t.td,{children:'Defaults to ".*"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"normVMinPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"the normal (ie non-emergency) minimum voltage per unit before it is considered to be undervoltage. Defaults to 0.9"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"normVMaxPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"the normal (ie non-emergency) maximum voltage per unit before it is considered to be overvoltage. Defaults to 1.054"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"emergVMinPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"the emergency minimum voltage, per unit. Defaults to 0.8"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"emergVMaxPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"the emergency maximum voltage, per unit. Defaults to 1.1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"baseFrequency"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"the baseline frequency. Defaults to 50"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVRegEnabled:"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Create Models with a Closed Loop Voltage Regulator at the Zone sub. If false, existing voltage regulator's in the zone sub will be used. Default is true"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVRegReplaceAll:"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Replace all existing Voltage Regulators with Closed Loop Voltage Regulator. If false existing zone sub regulators will be modelled as-is which may be in non-closed loop configuration. Default is true"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVRegSetPoint:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Scaling factor for the base voltage to form the set point (0.0-2.0). Default is 0.985"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVBand:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Band value in percentage. Default is 2."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopTimeDelay:"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"Time delay in seconds. Default is 100"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closedLoopVLimit:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Maximum voltage at regulating transformer's secondary bus."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultLoadWatts"}),(0,s.jsx)(t.td,{children:"List of Doubles"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default load watts when no load data is found. Default is null"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultGenWatts"}),(0,s.jsx)(t.td,{children:"List of Doubles"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default generation watts when no generation data is found. Default is null"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultLoadVar"}),(0,s.jsx)(t.td,{children:"List of Doubles"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default load car when no load data is found. Default is null"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultGenVar"}),(0,s.jsx)(t.td,{children:"List of Doubles"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default gen var when no load data is found. Default is null"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"splitPhaseDefaultLoadLossPercentage"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Default is 0.4"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultTapChangerTimeDelay:"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"Default is 100"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultTapChangerSetPointPu:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Default is 1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"defaultTapChangerBand:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Default is 2"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"splitPhaseLVKV:"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Default is 0.25"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"voltageBases"}),(0,s.jsx)(t.td,{children:"List of Doubles"}),(0,s.jsx)(t.td,{children:"A list of voltages used for for modelling, in Kv. Defaults to (0.4, 0.433, 6.6, 11.0, 22.0, 33.0, 66.0, 132.0)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxIter"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"the maximum number of iterations used in the OpenDSS model. Defaults to 25"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"maxControlIter"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"the maximum number of control loops in OpenDSS. Defaults to 20"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"mode"}),(0,s.jsx)(t.td,{children:"YEARLY or DAILY"}),(0,s.jsx)(t.td,{children:"the OpenDSS solve mode. Defaults to YEARLY"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"stepSizeMinutes"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"the step size time interval, in minutes, used in the OpenDSS model. Defaults to 60"})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"resultprocessor-config",children:"ResultProcessor Config"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Value"}),(0,s.jsx)(t.th,{children:"Type"}),(0,s.jsx)(t.th,{children:"Description and Defaults"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energyMeterVoltagesRaw"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energyMetersRaw"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"resultsPerMeter"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"overloadsRaw"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"voltageExceptionsRaw"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculatePerformanceMetrics"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if Performance Metrics will be calculated. Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populateEnhancedMetrics"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if Performance Metrics Enhanced will be calculated. Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populateEnhancedMetricsProfile"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populateDurationCurves"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if duration_curve output table will be calculated. Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populateConstraints"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if constraints output table will be calculated. Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populateWeeklyReports"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if weekly_reports output table will be calculated. Defaults to false."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculateNormalForLoadThermal"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if NormalForLoadThermal outputs will be calculated. Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculateEmergForLoadThermal"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if EmergForLoadThermal outputs will be calculated. Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculateNormalForGenThermal"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if NormalForGenThermal outputs will be calculated. Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculateEmergForGenThermal"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if EmergForGenThermal outputs will be calculated. Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculateCO2"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Determines if CO2 outputs will be calculated. Defaults to true."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"vmPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Voltage per-unit of voltage source. Defaults to 1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"vMinPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Minimum per unit voltage for which the load model selected and generator model is assumed to apply. Below this value, the load/gen model reverts to a constant impedance model. For generator model used, this is used to determine the upper current limit. For example, if Vminpu is 0.90 then the current limit is (1/0.90) = 111%."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"vMaxPu"}),(0,s.jsx)(t.td,{children:"Double"}),(0,s.jsx)(t.td,{children:"Maximum per unit voltage for which the load model selected and generator model is assumed to apply. Above this value, the load/gen model reverts to a constant impedance model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"loadModel"}),(0,s.jsx)(t.td,{children:"Int"}),(0,s.jsx)(t.td,{children:"Specifies how loads and generators in OpenDSS should be modelled. Options: 1: Standard constant P+jQ load. (Default) 2: Constant impedance load. 3: Const P, Quadratic Q (like a motor). 4: Nominal Linear P, Quadratic Q (feeder mix). Use this with CVRfactor. 5: Constant Current Magnitude 6: Const P, Fixed Q 7: Const P, Fixed Impedance Q"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collapseSWER"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Whether to collapse SWER network. Defaults to False"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calibration"}),(0,s.jsx)(t.td,{children:"Boolean"}),(0,s.jsx)(t.td,{children:"Whether to apply calibration modifications to model. Defaults to False"})]})]})]})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},4429:function(e,t,n){n.d(t,{R:()=>d,x:()=>l});var r=n(6540);let s={},i=r.createContext(s);function d(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);