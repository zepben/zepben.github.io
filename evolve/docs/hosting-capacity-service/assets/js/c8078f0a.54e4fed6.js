"use strict";(self.webpackChunkhosting_capacity_service=self.webpackChunkhosting_capacity_service||[]).push([["1135"],{1626:function(e,t,r){r.r(t),r.d(t,{frontMatter:()=>l,toc:()=>c,default:()=>x,metadata:()=>n,assets:()=>a,contentTitle:()=>d});var n=JSON.parse('{"id":"reference/configuration","title":"Configuration Options","description":"There are various elements that must be configured to successfully create a OpenDSS model from the input data, which are then used to run a Hosting Capacity Model work package.","source":"@site/docs/reference/configuration.mdx","sourceDirName":"reference","slug":"/reference/configuration","permalink":"/evolve/docs/hosting-capacity-service/next/reference/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"configuration","title":"Configuration Options","slug":"/reference/configuration","hide_table_of_contents":true},"sidebar":"theSidebar","previous":{"title":"Output Tables","permalink":"/evolve/docs/hosting-capacity-service/next/reference/output-tables"},"next":{"title":"Model Calibration Methodology","permalink":"/evolve/docs/hosting-capacity-service/next/reference/calibration-methodology"}}'),s=r(4848),i=r(4429),o=r(8127);let l={id:"configuration",title:"Configuration Options",slug:"/reference/configuration",hide_table_of_contents:!0},d="Work Package Configuration Options",a={},c=[{value:"Examples",id:"examples",level:2},{value:"SYFConfig Parameters",id:"syfconfig-parameters",level:3},{value:"ForecastConfig Parameters",id:"forecastconfig-parameters",level:4},{value:"FeederConfigs Parameters",id:"feederconfigs-parameters",level:4},{value:"FeederConfig Parameters",id:"feederconfig-parameters",level:4},{value:"LoadTime Parameters",id:"loadtime-parameters",level:4},{value:"FixedTimeLoadOverride / TimePeriodLoadOverride",id:"fixedtimeloadoverride--timeperiodloadoverride",level:4},{value:"GeneratorConfig Parameters",id:"generatorconfig-parameters",level:2},{value:"Model Config Parameters",id:"model-config-parameters",level:3},{value:"Processing Workflow",id:"processing-workflow",level:4},{value:"Network Normaliser",id:"network-normaliser",level:5},{value:"Network Collapser",id:"network-collapser",level:5},{value:"Meter Placement Config",id:"meter-placement-config",level:4},{value:"SwitchMeterPlacementConfig",id:"switchmeterplacementconfig",level:5},{value:"Solve Config",id:"solve-config",level:3},{value:"Raw Results Config",id:"raw-results-config",level:3},{value:"NodeLevelResultsConfig Parameters",id:"nodelevelresultsconfig-parameters",level:4},{value:"ResultProcessorConfig",id:"resultprocessorconfig",level:2},{value:"WriterConfig",id:"writerconfig",level:3},{value:"EnhancedMetricsConfig",id:"enhancedmetricsconfig",level:4},{value:"StoredResultsConfig",id:"storedresultsconfig",level:3},{value:"MetricsResultsConfig",id:"metricsresultsconfig",level:3}];function h(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"work-package-configuration-options",children:"Work Package Configuration Options"})}),"\n",(0,s.jsx)(t.p,{children:"There are various elements that must be configured to successfully create a OpenDSS model from the input data, which are then used to run a Hosting Capacity Model work package.\nThis page describes the configuration options available in running a Work Package via the Python API."}),"\n",(0,s.jsx)(t.p,{children:"This section outlines how the Hosting Capacity Module work packages are configured. These work packages represent a 'job' within the Hosting Capacity Module, and have a defined sets of scope and configuration:"}),"\n",(0,s.jsx)(t.p,{children:"The scope of the modelling to be undertaken is defined as the overall WorkPackageConfig object, which includes:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A name for the work package"}),"\n",(0,s.jsxs)(t.li,{children:["A syf_config object, which defines the scope of the work package in terms of:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Scenarios (in terms of the set(s) of uptake forecasts to be used)"}),"\n",(0,s.jsx)(t.li,{children:"Years (in terms of the calendar years to model or forecast)"}),"\n",(0,s.jsx)(t.li,{children:"Feeders (In terms of a list of feeders to model)"}),"\n",(0,s.jsx)(t.li,{children:"A time period that defines a set of AMI/NMI load data, which is to be used as the basis for the work package and adjusted by the selected forecasts."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["A generator_config object, which defines how the underlying power flow model are to be generated and solved, including:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Model configuration (in terms of how the power flow model is to be built, including what 'fixes' are to be applied to the model to help give better results from incomplete or inaccurate data)"}),"\n",(0,s.jsx)(t.li,{children:"Solve configuration (in terms of how the power flow model is to be solved)"}),"\n",(0,s.jsx)(t.li,{children:"Raw results configuration (in terms of what raw results are to be written out to storage)"}),"\n",(0,s.jsx)(t.li,{children:"Node Level Results Config (in terms of what node level results are to be included during the power flow solve)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["A result_processor_config object, which defines how the results of the work package are to be processed and written out, including:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Writer configuration, which controls what metrics are included, and how they are to be stored (although generally your administrator will have only deployed one output/storage option as part of deployment)"}),"\n",(0,s.jsx)(t.li,{children:"Stored results configuration (in terms of what stored results are to be written out)"}),"\n",(0,s.jsx)(t.li,{children:"Metrics configuration (in terms of what metrics are to be calculated and written out)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["A parameter called ",(0,s.jsx)(t.code,{children:"quality_assurance_processing"})," that is part of the umbrella WorkPackage Config object, which is used to enable extra reporting in the raw OpenDSS file, and is only relevant in the context of the ",(0,s.jsx)(t.a,{href:"../how-to-guides/opendss",children:"OpenDSS Exporting"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(o.A,{title:"WorkPackageConfig Example",children:[(0,s.jsx)(t.p,{children:"A simple, stand alone example of a WorkPackageConfig that does not reference an external file."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-WorkPackageConfig",children:'WorkPackageConfig(\n    name=config["work_package_name"],\n    syf_config=ForecastConfig(\n        feeders=["FeederA","FeederB", "FeederC"],\n        years=[2024,2025,2026],\n        scenarios=["scenario1", "scenario2"],\n        load_time=TimePeriod(\n            start_time="2023-02-22T00:00:00.00Z",\n            end_time="2024-02-22T00:00:00.00Z"\n        )\n    ),\n    generator_config=GeneratorConfig(\n        model=ModelConfig(\n            vmax_pu=1.2,\n            vmin_pu=0.8,\n            fix_single_phase_loads=True,\n            max_single_phase_load=15000.0,\n            max_load_service_line_ratio=1.0,\n            max_load_lv_line_ratio=2.0,\n            max_load_tx_ratio=2.0,\n            max_gen_tx_ratio=4.0,\n            fix_overloading_consumers=True,\n            fix_undersized_service_lines=True,\n        ),\n        solve=SolveConfig(step_size_minutes=30.0),\n    ),\n    result_processor_config=ResultProcessorConfig(\n        writer_config=WriterConfig(\n            output_writer_config=WriterOutputConfig(\n                enhanced_metrics_config=EnhancedMetricsConfig(\n                    populate_enhanced_metrics_profile=False,\n                ),\n            ),\n        ),\n        stored_results=StoredResultsConfig(\n            energy_meter_voltages_raw=False,\n            energy_meters_raw=False,\n            overloads_raw=True,\n            voltage_exceptions_raw=False,\n        ),\n        metrics=MetricsResultsConfig(False),\n    ),\n)\n'})}),(0,s.jsx)(t.p,{children:"An example of a WorkPackageConfig that references an external file for the SYFConfig, which is a ForecastConfig in this case."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-WorkPackageConfig",children:'WorkPackageConfig(\n    name=config["work_package_name"],\n    syf_config=forecast_config,\n    generator_config=GeneratorConfig(\n        model=ModelConfig(\n            vmax_pu=1.2,\n            vmin_pu=0.8,\n            fix_single_phase_loads=True,\n            max_single_phase_load=15000.0,\n            max_load_service_line_ratio=1.0,\n            max_load_lv_line_ratio=2.0,\n            max_load_tx_ratio=2.0,\n            max_gen_tx_ratio=4.0,\n            fix_overloading_consumers=True,\n            fix_undersized_service_lines=True,\n        ),\n        solve=SolveConfig(step_size_minutes=30.0),\n        node_level_results_config=NodeLevelResultsConfig(\n            collect_voltage=True,\n            collect_current=True,\n            collect_power=True,\n            mrids_to_collect=["123", "456", "789"],\n        ),\n    ),\n    result_processor_config=ResultProcessorConfig(\n        writer_config=WriterConfig(\n            output_writer_config=WriterOutputConfig(\n                enhanced_metrics_config=EnhancedMetricsConfig(\n                    populate_enhanced_metrics_profile=False,\n                ),\n            ),\n        ),\n        stored_results=StoredResultsConfig(\n            energy_meter_voltages_raw=False,\n            energy_meters_raw=False,\n            overloads_raw=True,\n            voltage_exceptions_raw=False,\n        ),\n        metrics=MetricsResultsConfig(False),\n    ),\n)\n'})}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"forecast_config"})," object is created using the values from the ",(0,s.jsx)(t.code,{children:"config"})," dictionary."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'forecast_config = ForecastConfig(\n        feeders=config["feeders"],\n        years=config["forecast_years"],\n        scenarios=config["scenarios"],\n        load_time=TimePeriod(\n            start_time=datetime.fromisoformat(config["load_time"]["start1"]),\n            end_time=datetime.fromisoformat(config["load_time"]["end1"]),\n        )\n    )\n'})}),(0,s.jsx)(t.p,{children:"Sample config.json for ForecastConfig"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "work_package_name": "test_work_package",\n  "feeders": [\n    "feeder1", "feeder2", "feeder3"\n  ],\n  "load_time": {\n    "start1": "2023-02-22T00:00:00.00Z",\n    "end1": "2024-02-22T00:00:00.00Z",\n  },\n  "forecast_years": [\n    2024\n  ],\n  "scenarios": [\n    "base"\n  ]\n}\n'})})]}),"\n",(0,s.jsx)(t.h1,{id:"detailed-option-descriptions-and-defaults",children:"Detailed Option Descriptions and Defaults"}),"\n",(0,s.jsx)(t.admonition,{title:"note",type:"info",children:(0,s.jsx)(t.p,{children:"The default values listed below are the underlying HCM defaults, and may be overridden based on your organisations deployment. Please check with Zepben for any questions about default values in your environment."})}),"\n",(0,s.jsx)(t.h1,{id:"work-package-config",children:"Work Package Config"}),"\n",(0,s.jsx)(t.p,{children:"The Work Package Config is the main configuration object that contains all the necessary configurations for running a Hosting Capacity Model work package. It includes the forecast configuration, generator configuration, result processor configuration, and quality assurance processing flag (quality_assurance_processing)."}),"\n",(0,s.jsx)(t.h3,{id:"syfconfig-parameters",children:"SYFConfig Parameters"}),"\n",(0,s.jsx)(t.p,{children:"The SYFConfig object is used to define the SYF (scenario, year, feeder) and time parameters for the work package."}),"\n",(0,s.jsx)(t.p,{children:"It can be one of two types \u2014 a ForecastConfig or a FeederConfig. These have very similar structures and parameters.\nThe ForecastConfig is used to define the SYF that applies to all feeders in a given work package, while the FeederConfigs allows for individual SYF and time parameters for each feeder in the work package."}),"\n",(0,s.jsx)(t.admonition,{title:"Note",type:"info",children:(0,s.jsxs)(t.p,{children:["Note that ",(0,s.jsx)(t.code,{children:"base"})," scenario is a hardcoded scenario that is always included in addition to any scenarios you provide in the configuration. The ",(0,s.jsx)(t.code,{children:"base"})," scenario represents the current state of the network without any additional DER uptake, and is used as a reference point for comparing the impact of other scenarios. ",(0,s.jsx)(t.strong,{children:"Do not"})," name a scenario ",(0,s.jsx)(t.code,{children:"base"})," as this will break things."]})}),"\n",(0,s.jsxs)(o.A,{title:"ForecastConfig",children:[(0,s.jsx)(t.h4,{id:"forecastconfig-parameters",children:"ForecastConfig Parameters"}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feeders"}),(0,s.jsx)(t.td,{children:"List[String]"}),(0,s.jsx)(t.td,{children:"List of feeder mRIDs for the feeders we want to model in this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"scenarios"}),(0,s.jsx)(t.td,{children:"List[String]"}),(0,s.jsx)(t.td,{children:"List of scenario ids that we want apply to the feeders in this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"years"}),(0,s.jsx)(t.td,{children:"List[Int]"}),(0,s.jsx)(t.td,{children:"List of years to model for each scenario/feeder combination."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_time"}),(0,s.jsx)(t.td,{children:"LoadTime"}),(0,s.jsx)(t.td,{children:"Can either be FixedTime or TimePeriod. Date time range/period specifying the period of load data to use in the creation of the model. All  must correspond to a valid time range in your EAS instance and should be either exactly one day or one year. Please consult your System Administrator to understand the range of data available. This is specified in the local timezone of your provided AMI data. Typically, customers provide their AMI data in 'NEM time' which is GMT+10. This must correspond to a valid time in your EAS instance."})]})]})]})]}),"\n",(0,s.jsxs)(o.A,{title:"FeederConfigs",children:[(0,s.jsx)(t.h4,{id:"feederconfigs-parameters",children:"FeederConfigs Parameters"}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"configs"}),(0,s.jsx)(t.td,{children:"List[FeederConfig]"}),(0,s.jsx)(t.td,{children:"A list of feeder specific individual configurations."})]})})]}),(0,s.jsx)(t.h4,{id:"feederconfig-parameters",children:"FeederConfig Parameters"}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feeder"}),(0,s.jsx)(t.td,{children:"String"}),(0,s.jsx)(t.td,{children:"The feeder mRIDs for the feeder we want to model in this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"scenarios"}),(0,s.jsx)(t.td,{children:"List[String]"}),(0,s.jsx)(t.td,{children:"List of scenario ids that we want apply to the feeders in this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"years"}),(0,s.jsx)(t.td,{children:"List[Int]"}),(0,s.jsx)(t.td,{children:"List of years to model for each scenario/feeder combination."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_time"}),(0,s.jsx)(t.td,{children:"LoadTime"}),(0,s.jsx)(t.td,{children:"Can either be FixedTime or TimePeriod. Date time range/period specifying the period of load data to use in the creation of the model. All  must correspond to a valid time range in your EAS instance and should be either exactly one day or one year. Please consult your System Administrator to understand the range of data available. Typically, customers provide their AMI data in 'NEM time' which is GMT+10. This must correspond to a valid time in your EAS instance."})]})]})]})]}),"\n",(0,s.jsxs)(o.A,{title:"LoadTime Parameters",children:[(0,s.jsx)(t.h4,{id:"loadtime-parameters",children:"LoadTime Parameters"}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"start_time"}),(0,s.jsx)(t.td,{children:"string"}),(0,s.jsx)(t.td,{children:"(used if ForecastConfig/FeederConfig load_time = TimePeriod) Date time that represents the start of the time period for the load data used within the Work Package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"end_time"}),(0,s.jsx)(t.td,{children:"string"}),(0,s.jsx)(t.td,{children:"(used if ForecastConfig/FeederConfig load_time = TimePeriod) Date time that represents the end of the time period for the load data used within the Work Package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_time"}),(0,s.jsx)(t.td,{children:"string"}),(0,s.jsx)(t.td,{children:"(used if ForecastConfig/FeederConfig load_time = FixedTime) Date time that represents the fixed time for the load data used within the Work Package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_overrides"}),(0,s.jsx)(t.td,{children:"dict[string,FixedTimeLoadOverride] or dict[string,TimePeriodLoadOverride]"}),(0,s.jsx)(t.td,{children:"A dictionary of load (and generation) overrides to be applied for specific NMIs (the string in the dict object). The FixedTimeLoadOverride/TimePeriodLoadOverride are classes that defines the structure for load overrides. They have nearly identical structure, see below."})]})]})]}),(0,s.jsx)(t.h4,{id:"fixedtimeloadoverride--timeperiodloadoverride",children:"FixedTimeLoadOverride / TimePeriodLoadOverride"}),(0,s.jsx)(t.p,{children:"The only difference between TimePeriodLoadOverride and FixedTimeLoadOverride is that TimePeriodLoadOverride requires the number of entries for the default_load_watts, default_gen_watts, default_load_var, and default_gen_var to either a day or a years worth of values (as per the configured load_interval_length_hours, eg for 0.5, means 48 entries for daily and 17520 for yearly)."}),(0,s.jsx)(t.p,{children:"Within the list of values for each parameter in the FixedTimeLoadOverride can be a either a single entry or multiple entries. If a single entry is provided, the load flow study will be run just once, if multiple entries are provided, the load flow study will be run once for each entry in the list, keeping all other load values the same. If the number of entries in the up to 4 lists (gen/load, watt/vars) is different, values in shorter lists will be repeated to match the longest list."}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_watts"}),(0,s.jsx)(t.td,{children:"List[float]"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default load watts when no load data is found. If using net load values, negative loads are treated as exports."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"gen_watts"}),(0,s.jsx)(t.td,{children:"List[float]"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default gen watts when no load data is found."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_var"}),(0,s.jsx)(t.td,{children:"List[float]"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default load var when no load data is found. If using net load values, negative loads are treated as exports."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"gen_var"}),(0,s.jsx)(t.td,{children:"List[float]"}),(0,s.jsx)(t.td,{children:"A list of readings to be used as default gen var when no load data is found."})]})]})]}),(0,s.jsx)(t.admonition,{title:"Note on load_time parameter",type:"caution",children:(0,s.jsx)(t.p,{children:"There are two parameters called load_time, one is a TimePeriod object and the other is a string that represents a fixed time. Be careful to ensure the correct one is used in the correct context."})})]}),"\n",(0,s.jsx)(t.h2,{id:"generatorconfig-parameters",children:"GeneratorConfig Parameters"}),"\n",(0,s.jsx)(t.p,{children:"The GeneratorConfig object is used to define the configuration for generating the power flow models. It includes the model configuration, solve configuration, and raw results configuration."}),"\n",(0,s.jsx)(t.h3,{id:"model-config-parameters",children:"Model Config Parameters"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"vm_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.0"}),(0,s.jsxs)(t.td,{children:["The per unit voltage of the energy source defined at the head of the feeder within each feeder model. ",(0,s.jsx)(t.em,{children:"Depreciated in favour of the 4 more specific values below"})]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_vmin_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.80"}),(0,s.jsx)(t.td,{children:"Minimum per unit voltage for which the load model selected is assumed to apply. Below this value, the load model reverts to a constant impedance model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_vmax_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.15"}),(0,s.jsx)(t.td,{children:"Maximum per unit voltage for which the load model selected is assumed to apply. Above this value, the load model reverts to a constant impedance model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"gen_vmin_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.70"}),(0,s.jsx)(t.td,{children:"Minimum per unit voltage for which the generator model selected is assumed to apply. Below this value, the generator model reverts to a constant impedance model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"gen_vmax_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"2.00"}),(0,s.jsx)(t.td,{children:"Maximum per unit voltage for which the generator model selected is assumed to apply. Above this value, the generator model reverts to a constant impedance model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_model"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"1"}),(0,s.jsxs)(t.td,{children:["Load/generator modeling mode (1 to 7): Specifies how loads and generators in OpenDSS should be modelled. Options: ",(0,s.jsx)("br",{})," 1: Standard constant P+jQ load. (Default) ",(0,s.jsx)("br",{})," 2: Constant impedance load. ",(0,s.jsx)("br",{})," 3: Const P, Quadratic Q (like a motor). ",(0,s.jsx)("br",{})," 4: Nominal Linear P, Quadratic Q (feeder mix). Use this with CVRfactor. ",(0,s.jsx)("br",{})," 5: Constant Current Magnitude ",(0,s.jsx)("br",{})," 6: Const P, Fixed Q ",(0,s.jsx)("br",{})," 7: Const P, Fixed Impedance Q."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collapse_swer"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Flag to control the collapse of SWER networks back to their Isolation Transformers, to simplify models."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calibration"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Controls various properties used in the Calibration process. Will be turned on automatically during a Calibration Run, leave as false otherwise."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"use_span_level_threshold"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsxs)(t.td,{children:["Controls whether the system uses span level ratings (",(0,s.jsx)(t.code,{children:"designedrating"})," from CIM) or only normal current rating (",(0,s.jsx)(t.code,{children:"ratedcurrent"})," from CIM) values during the Rating Normalising step."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"rating_threshold"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.0"}),(0,s.jsx)(t.td,{children:"Percentage threshold used for current rating comparisons in the network normaliser. A value of 0% finds exact matches only, while higher values allow for more network simplification and thus faster solve times.  Valid range: 0.0% to positive infinity (values higher than ~10-20% could lead to model oversimplification).  See detailed section below for more information"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"simplify_plsi_threshold"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.0"}),(0,s.jsx)(t.td,{children:"Percentage threshold used for both PerLengthSequenceImpedance (PLSI) comparisons in the network normaliser. A value of 0% finds exact matches only, while higher values allow for more network simplification and thus faster solve times. Valid range: 0.0% to positive infinity (values higher than ~10-20% could lead to model oversimplification). See detailed section below for more information"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"p_factor_base_exports"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsxs)(t.td,{children:["Power factor for base model generators. If ",(0,s.jsx)(t.code,{children:"null"})," the model will use the reactive power specified in the load profiles."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"p_factor_forecast_pv"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.0"}),(0,s.jsx)(t.td,{children:"Power factor to set for scenario (forecast) model Generators during model translation."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"p_factor_base_imports"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"Power factor to set for base model Loads during model translation. If null the model will use the reactive power specified in the load profiles."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fix_single_phase_loads"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsxs)(t.td,{children:["Finds consumers with a peak load (within the modelled time period) greater than the configured max_single_phase_load value. ",(0,s.jsx)("br",{})," Upgrades these consumers to three-phase loads to correct data inaccuracies in reported phase numbers. ",(0,s.jsx)("br",{})," Traces upstream to the distribution transformer and spreads 3 phases (ABCN) back to the transformer where possible."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_single_phase_load"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"30000.0"}),(0,s.jsx)(t.td,{children:"The max peak load for a single phase customer, beyond which will trigger the single phase load fixing algorithm mentioned above."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fix_overloading_consumers"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Finds consumers that have peak load or generation (within the modelled time period) greater than the capacity of the transformer they are attached to by a configurable factor, and then reconfigures them to be HV consumers (attached above the transformer). The aim is to identify HV consumers that have been incorrectly connected as LV consumers, and resolve this connectivity."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_load_tx_ratio"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"3.0"}),(0,s.jsx)(t.td,{children:"The maximum load to transformer rating ratio for a single consumer to trigger the overloading consumer fixer. For a ratio of 2, if a customer with a peak 30kW load was downstream of a 10kVA transformer, this would be a ratio of 3:1 and thus trigger the overloading consumers fixer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_gen_tx_ratio"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"10.0"}),(0,s.jsx)(t.td,{children:"The maximum generation to transformer rating ratio for a single consumer to trigger the overloading consumer fixer. For a ratio of 2, if a customer with peak generation of 30kW was downstream of a 10kVA transformer, this would be a ratio of 3:1 and thus trigger the overloading consumers fixer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"fix_undersized_service_lines"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Finds consumers that have a peak load (within the modelled time period) greater than the capacity of the service line of the consumer by a configured factor. The intent is to find service lines that have unrealistically low current ratings which would stop convergence, and upgrade them to sensible ratings. When a conductors rating is upgraded, the impedance is also upgraded to match, utilising a pre-configured catalogue of rating and impedance data, and matching the phase configuration of the consumer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_load_service_line_ratio"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.5"}),(0,s.jsx)(t.td,{children:"The maximum load to service line rating ratio to trigger the undersized service lines fixer. For example given a ratio of 2, if a customer with peak load of 10kW had a service line supporting only 5kVA, this would be a ratio of 2:1 and thus trigger the undersized service line fixer. Note: service lines are generally considered to be the conductors immediately connecting to a consumer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_load_lv_line_ratio"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"2.0"}),(0,s.jsx)(t.td,{children:"The maximum load to LV line rating ratio to trigger the undersized service lines fixer for LV conductors. For example given a ratio of 5, if a customer with peak load of 50kW was connected to LV backbone conductors supporting only 10kVA, this would be a ratio of 5:1 and thus trigger the undersized service line fixer for the LV conductors. Note the LV line fixer will fix all conductors upstream of the consumer up to the distribution transformer they are connected to."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collapse_lv_networks"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Flag to control whether to collapse lv network in the model."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feeder_scenario_allocation_strategy"}),(0,s.jsx)(t.td,{children:"str"}),(0,s.jsx)(t.td,{children:"ADDITIVE"}),(0,s.jsx)(t.td,{children:"Strategy for scenario ev, pv and bess allocation. ADDITIVE will be each year is built upon the last years allocation, while RANDOM will be a different allocation every year"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_v_reg_enabled"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Create models with a Closed Loop Voltage Regulator at the Zone sub. If false, existing voltage regulator's in the zone sub will be used."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_v_reg_replace_all"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Replace all existing Voltage Regulators with Closed Loop Voltage Regulator. If false existing zone sub regulators will be modelled as-is which may be in non-closed loop configuration."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_v_reg_set_point"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.985"}),(0,s.jsx)(t.td,{children:"Scaling factor for the base voltage to form the set point (0.0-2.0)."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_v_band"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"2.0"}),(0,s.jsx)(t.td,{children:"VBand value in percentage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_time_delay"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsx)(t.td,{children:"Time delay (seconds) for closed loop control"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"closed_loop_v_limit"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.1"}),(0,s.jsx)(t.td,{children:"Maximum voltage at regulating transformer's secondary bus."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"default_tap_changer_time_delay"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"100"}),(0,s.jsx)(t.td,{children:"Tap changer time delay (seconds)."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"default_tap_changer_set_point_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.0"}),(0,s.jsx)(t.td,{children:"Tap changer set point."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"default_tap_changer_band"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"2.0"}),(0,s.jsx)(t.td,{children:"Tap changer band value."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"split_phase_default_load_loss_percentage"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.4"}),(0,s.jsx)(t.td,{children:"Load loss % for split-phase transformers."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"split_phase_lv_kv"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.25"}),(0,s.jsx)(t.td,{children:"Split phase LV voltage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"swer_voltage_to_line_voltage"}),(0,s.jsx)(t.td,{children:"List[List[int]]"}),(0,s.jsxs)(t.td,{children:["[230,400]  ",(0,s.jsx)("br",{})," [240,415]  ",(0,s.jsx)("br",{})," [250,433]  ",(0,s.jsx)("br",{})," [6350,11000]  ",(0,s.jsx)("br",{})," [6400,11000]  ",(0,s.jsx)("br",{})," [12700,22000]  ",(0,s.jsx)("br",{})," [19100,33000]"]}),(0,s.jsx)(t.td,{children:"Mapping SWER voltages to line-to-line."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_placement"}),(0,s.jsx)(t.td,{children:"LoadPlacement"}),(0,s.jsx)(t.td,{children:"PER_USAGE_POINT"}),(0,s.jsx)(t.td,{children:"Create loads per UsagePoint (PER_ENERGY_CONSUMER) or EnergyConsumer (PER_ENERGY_CONSUMER)"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"load_interval_length_hours"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.5"}),(0,s.jsx)(t.td,{children:"Load interval in fractions of an hour, 1.0 = 60 minute intervals, 0.5 = 30 minute intervals"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"meter_placement_config"}),(0,s.jsx)(t.td,{children:"MeterPlacementConfig"}),(0,s.jsx)(t.td,{children:"MeterPlacementConfig()"}),(0,s.jsx)(t.td,{children:"Configuration to determine where to place EnergyMeters for collecting results, see below for details."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"seed"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"A seed to use when generating the model. Re-using the same seed will result in the same model being generated.This mainly controls the random scattering of DER devices such as solar and batteries within a feeder, matching the forecasts provided."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"transformer_tap_settings"}),(0,s.jsx)(t.td,{children:"str"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"The name of the set of distribution transformer tap settings to be applied to the model from the Calibration results (calibrated_taps table). If null, tap settings from the network model will be applied."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ctPrimScalingFactor"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"The scaling factor to apply to the primary current of CTs in the model. This is used to adjust the primary current readings to match the expected primary current of the transformer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"simplify_network"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Flag to control whether to the network model simplifcation steps will run, as configured in other parameters. If this is False, then other values will be overridden and no network collapsing, simplifiying or normalising will occur."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collapse_negligible_impedances"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Flag to control whether to collapse conductors with negligible impedance during network simplification. Negligible means either Line Resistance is less than 0.001 Ohms OR Line Reactance is less than 0.001 Ohms. This is useful for removing very short sections of line that are not significant to the model. 0.001 Ohms is the default, and can be changed on a per environment level, contact Zepben. This was previously an implicit step of model building and always true, now configurable. Leaving it to true is recommended."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"combine_common_impedances"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Flag to control whether to combine conductors with common impedance during network simplification. This was previously an implicit step of model building and always true, now configurable. Leaving it to true is recommended. If this is false, other parameters that control common impedance collapsing will not run."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"emergAmpScaling"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.5"}),(0,s.jsx)(t.td,{children:"Scaling factor for emergency current rating in lineCodes (Defaults to 1.5, which means the emergency threshold is 150% of normal current threshold)."})]})]})]}),"\n",(0,s.jsxs)(o.A,{title:"Span Level Ratings and Improved Network Collapsing - Detailed Explanation",children:[(0,s.jsxs)(t.p,{children:["The Span Level Ratings feature enables more granular control over network model construction by utilizing individual span ratings rather than predefined line type categories. The Improved Network Collapsing allows for faster solve times by allowing collapsing similar network sections based on their electrical characteristics, instead of just exact matches as previously. The ",(0,s.jsx)(t.code,{children:"rating_threshold"})," and ",(0,s.jsx)(t.code,{children:"simplify_plsi_threshold"})," can be used with or without Span Level Ratings. It was introduced to manage the additional complexity that span level ratings introduces in terms of node count, and thus reduce solve time back to more manageable levels, but will also benefit models that do not use span level ratings."]}),(0,s.jsx)(t.h4,{id:"processing-workflow",children:"Processing Workflow"}),(0,s.jsx)(t.p,{children:"The span level ratings feature operates through a two-stage process in the Network Normaliser, followed by the Network Collapser:"}),(0,s.jsx)(t.h5,{id:"network-normaliser",children:"Network Normaliser"}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Step 1: PLSI Normalising"})}),(0,s.jsx)(t.p,{children:"For each pair of neighbouring conductors:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Compares PLSI parameters (r0, r, x0, x) (see ",(0,s.jsx)(t.a,{href:"https://zepben.github.io/evolve/docs/cim/ewb/IEC61970/Base/Wires/PerLengthSequenceImpedance/",children:"Per Length Sequence Impedance (PLSI)"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:["If all parameters are within the ",(0,s.jsx)(t.code,{children:"simplify_plsi_threshold"}),", calculates ",(0,s.jsx)(t.strong,{children:"length-weighted averages"})," for each parameter and assigns it to both conductors"]}),"\n"]}),(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Step 2: Rating Normalising"})}),(0,s.jsx)(t.p,{children:"For each pair of neighbouring conductors:"}),(0,s.jsxs)(t.p,{children:["When ",(0,s.jsx)(t.code,{children:"use_span_level_threshold"})," = ",(0,s.jsx)(t.code,{children:"true"}),":"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Compares span level ratings (",(0,s.jsx)(t.code,{children:"designedrating"})," CIM values) between neighbouring conductors"]}),"\n",(0,s.jsxs)(t.li,{children:["If ratings are within the ",(0,s.jsx)(t.code,{children:"rating_threshold"}),", assigns the ",(0,s.jsx)(t.strong,{children:"minimum value"})," to both conductors"]}),"\n"]}),(0,s.jsxs)(t.p,{children:["When ",(0,s.jsx)(t.code,{children:"use_span_level_threshold"})," = ",(0,s.jsx)(t.code,{children:"false"}),":"]}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Compares normal current (",(0,s.jsx)(t.code,{children:"ratedcurrent"})," CIM values) values between neighbouring conductors, ignoring any ",(0,s.jsx)(t.code,{children:"designedrating"})," values that may or may not be present"]}),"\n",(0,s.jsxs)(t.li,{children:["If ratings are within the ",(0,s.jsx)(t.code,{children:"rating_threshold"}),", assigns the ",(0,s.jsx)(t.strong,{children:"minimum value"})," to both conductors"]}),"\n"]}),(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Example"}),": With ",(0,s.jsx)(t.code,{children:"rating_threshold"})," = ",(0,s.jsx)(t.code,{children:"5%"}),", two neighbouring conductors with ratings of 96A and 100A would be normalised (since (100-96)/96 = 4.17% < 5%), but conductors with 95A and 100A would not be normalised (since (100-95)/95 = 5.26% > 5%)."]}),(0,s.jsx)(t.h5,{id:"network-collapser",children:"Network Collapser"}),(0,s.jsxs)(t.p,{children:["Collapses neighbouring network sections with the same number of phases, and identical PLSI values and current rating (either ",(0,s.jsx)(t.code,{children:"ratedcurrent"})," or ",(0,s.jsx)(t.code,{children:"designedrating"})," depending on configuration, as detailed above) into longer sections to reduce model complexity. No threshold comparison is needed at this stage since values have already been normalised above."]}),(0,s.jsx)(t.admonition,{title:"Notes",type:"info",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"CIM Data"}),": To use Span Level Ratings, (",(0,s.jsx)(t.code,{children:"use_span_level_threshold = true"}),"), the CIM model needs to have ",(0,s.jsx)(t.code,{children:"designedrating"})," imported as part of the data ingestion process."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Missing Data Handling"}),": If ",(0,s.jsx)(t.code,{children:"designedrating"})," values are not found in the CIM model when ",(0,s.jsx)(t.code,{children:"use_span_level_threshold = true"}),", the system automatically falls back to using normal current (",(0,s.jsx)(t.code,{children:"ratedcurrent"}),") values for those conductors. If those are also not found, conductors are assumed to have ",(0,s.jsx)(t.code,{children:"null"})," rating, and will not be normalised or collapsed. In the Solver stage (in OpenDSS), conductors with ",(0,s.jsx)(t.code,{children:"null"})," ratings will be treated as having a normal current rating of 10A and a emergency rating of 15A (this is a hardcoded default and ideally should never be hit in practice by having current ratings in the CIM model for all conductors)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Logging"}),": The sections being normalised and collapsed are logged for debugging purposes, allowing users to assess the impact of their threshold settings on the network model."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Threshold Values"}),": The ",(0,s.jsx)(t.code,{children:"rating_threshold"})," and ",(0,s.jsx)(t.code,{children:"simplify_plsi_threshold"})," determines how similar parameters must be for sections to be considered similiar enough to normalise. Recommended values are between 1-10% for most use cases, which will result in improved solve times compared to 0%, without losing too much model detail. Values above ~10-20% should be used with caution as they may lead to oversimplification of the network model, although this will improve solve time further."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Disabling this feature"}),": To restore legacy network rating and collapsing behaviour, set ",(0,s.jsx)(t.code,{children:"use_span_level_threshold"})," to ",(0,s.jsx)(t.code,{children:"false"}),", ",(0,s.jsx)(t.code,{children:"simplify_plsi_threshold"})," to ",(0,s.jsx)(t.code,{children:"0%"})," and ",(0,s.jsx)(t.code,{children:"rating_threshold"})," to ",(0,s.jsx)(t.code,{children:"0%"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Comparison Formula"})," All comparisons use the perspective of the lower value. For example, if comparing 0.1 and 0.11, the calculation is (0.11-0.1)/0.1 = 10%."]}),"\n"]})})]}),"\n",(0,s.jsx)(t.h4,{id:"meter-placement-config",children:"Meter Placement Config"}),"\n",(0,s.jsx)(t.p,{children:"The Meter Placement Config is used to determine where to place EnergyMeters for collecting results (where the measurement zones are). It includes the type of placement and the configuration for the placement."}),"\n",(0,s.jsx)(t.p,{children:":::\nIf a downstream trace encounters an LV circuit loop (where tracing returns to the original fuse), the system detects this condition and creates the measurement_zone at the transformer only, excluding downstream fuses. This ensures consistent, reproducible measurement_zones across multiple runs.\n:::"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"feeder_head"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Whether to place a meter at the voltage source at the feeder head."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"dist_transformers"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Whether to place a meter at the secondary winding of each distribution transformer."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"switch_meter_placement_configs"}),(0,s.jsx)(t.td,{children:"List[SwitchMeterPlacementConfig]"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"Specifies which switch classes to place meters at, and the regex pattern to match for in the switch names. See below for details."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energy_consumer_meter_group"}),(0,s.jsx)(t.td,{children:"str"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsxs)(t.td,{children:["The ID of the meter group to use for populating EnergyMeters at EnergyConsumers, as per the meter_group_id of the energy_consumer_meters input table. For more information, see the ",(0,s.jsx)(t.a,{href:"../reference/input-tables#energy-consumer-meters",children:"Energy Consumer Meters section"})," of the Input Tables documentation."]})]})]})]}),"\n",(0,s.jsx)(t.h5,{id:"switchmeterplacementconfig",children:"SwitchMeterPlacementConfig"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"meter_switch_class"}),(0,s.jsx)(t.td,{children:"SwitchClass"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"The CIM class of Switch to create meters at. Options are BREAKER, DISCONNECTOR, FUSE, JUMPER, LOAD_BREAK_SWITCH or RECLOSER"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"name_pattern"}),(0,s.jsx)(t.td,{children:"str"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsxs)(t.td,{children:['A Regex pattern to match on for Switch names. Eg, ".',(0,s.jsx)(t.em,{children:"Circuit Head Switch."}),"\" and DISCONNECTOR set for meter_switch_class places energy meters (and thus measurement zones) on all switches of class 'DISCONNECTOR' with a name that includes the string 'Circuit Head Switch' in it. See ",(0,s.jsx)(t.a,{href:"https://regexr.com/",children:"https://regexr.com/"})," for more information on regular expressions and to test that your pattern matches your needs."]})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"solve-config",children:"Solve Config"}),"\n",(0,s.jsx)(t.p,{children:"The Solve config related to options used in the OpenDSS model."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"norm_vmin_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.9"}),(0,s.jsx)(t.td,{children:"Normal minimum per unit voltage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"norm_vmax_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.054"}),(0,s.jsx)(t.td,{children:"Normal maximum per unit voltage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"emerg_vmin_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"0.8"}),(0,s.jsx)(t.td,{children:"Emergency minimum per unit voltage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"emerg_vmax_pu"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"1.1"}),(0,s.jsx)(t.td,{children:"Emergency maximum per unit voltage."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"base_frequency"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"50"}),(0,s.jsx)(t.td,{children:"Base frequency for the simulation, in Hz"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"voltage_bases"}),(0,s.jsx)(t.td,{children:"List[float]"}),(0,s.jsx)(t.td,{children:"(0.4, 0.433, 6.6, 11.0, 22.0, 33.0, 66.0, 132.0)"}),(0,s.jsx)(t.td,{children:"List of voltage base values, in kV"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_iter"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"25"}),(0,s.jsx)(t.td,{children:"Max solve iterations to run in the underlying OpenDSS simulation before failing."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"max_control_iter"}),(0,s.jsx)(t.td,{children:"int"}),(0,s.jsx)(t.td,{children:"20"}),(0,s.jsx)(t.td,{children:"Max control iterations to run in the underlying OpenDSS before failing."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"mode"}),(0,s.jsx)(t.td,{children:"str"}),(0,s.jsx)(t.td,{children:"YEARLY"}),(0,s.jsx)(t.td,{children:"Run OpenDSS in YEARLY or DAILY mode."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"step_size_minutes"}),(0,s.jsx)(t.td,{children:"float"}),(0,s.jsx)(t.td,{children:"60"}),(0,s.jsx)(t.td,{children:"The step size for the solver in minutes."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"raw-results-config",children:"Raw Results Config"}),"\n",(0,s.jsx)(t.p,{children:"Whether to produce raw results generated from OpenDSS. You will likely always want defaults for this, as setting any of these to False will limit the results you get and should only be used as a potential performance optimisation if they are unnecessary."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energy_meter_voltages_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Produce energy meter voltages results."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energy_meters_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Produce energy meter results."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"results_per_meter"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Produce results per EnergyMeter."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"overloads_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Produce overloads."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"voltage_exceptions_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Produce voltage exceptions."})]})]})]}),"\n",(0,s.jsx)(t.h4,{id:"nodelevelresultsconfig-parameters",children:"NodeLevelResultsConfig Parameters"}),"\n",(0,s.jsxs)(t.p,{children:["This sections controls how the ",(0,s.jsx)(t.code,{children:"node_level_results"})," table is populated. If any of the last 5 values are not null/false, the table will be populated, otherwise it will not.  It is used to collect results at specific nodes in the network, such as switches, transformers, conductors and energy consumers. This table is independant from all other output tables, they can be turned on or off and it will have no impact on the Node Level Results table, and vice versa."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_voltage"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Include voltage values in node level results."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_current"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Include current values in node level results."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_power"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"true"}),(0,s.jsx)(t.td,{children:"Include power values in node level results."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"mrids_to_collect"}),(0,s.jsx)(t.td,{children:"List[str]"}),(0,s.jsx)(t.td,{children:"null"}),(0,s.jsx)(t.td,{children:"A list of MRIDs to collect node level results at. Note: Depending on network simplification and translation, these MRIDs may not exist in the final OpenDSS and no results will be collected in that case. Note that if running work package across multiple feeders, this will generate a lot of logs as the MRIDs won't be found on feeders they are not in, but the core functionality will still work."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_all_switches"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Collect node level results at all switches in the feeders that are part of this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_all_transformers"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Collect node level results at all transformers in the feeders that are part of this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_all_conductors"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Collect node level results at all conductors in the feeders that are part of this work package."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"collect_all_energy_consumers"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"false"}),(0,s.jsx)(t.td,{children:"Collect node level results at all energy consumers in the feeders that are part of this work package."})]})]})]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Note: depending on the settings used for collapsing and simplifying switches, transformers and conductors, the results collected may not match 1:1 with the objects in the CIM model, as some may have been collapsed or simplified away (particularly conductors). If you want to ensure results are collected at every single location, you should set ",(0,s.jsx)(t.code,{children:"simplify_network"})," to ",(0,s.jsx)(t.code,{children:"false"})," in the GeneratorConfig."]})}),"\n",(0,s.jsx)(t.h2,{id:"resultprocessorconfig",children:"ResultProcessorConfig"}),"\n",(0,s.jsx)(t.p,{children:"The Result Processor Config is used to configure how the results of the work package are processed and stored. Includes sub-configs; WriterConfig (containing the WriterOutputConfig, which itself contains the EnhancedMetricsConfig), the StoredResultsConfig and MetricsResultsConfig."}),"\n",(0,s.jsx)(t.h3,{id:"writerconfig",children:"WriterConfig"}),"\n",(0,s.jsx)(t.p,{children:"The Writer Config is used to configure how the results of the work package are written. It includes the type of writer (Postgres or Parquet) and the configuration for the output writer."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"writer_type"}),(0,s.jsx)(t.td,{children:"WriterType"}),(0,s.jsx)(t.td,{children:"POSTGRES or PARQUET"}),(0,s.jsx)(t.td,{children:"Whether to write output to Parquet files or a Postgres database. Check with your administrator which result types are supported."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"output_writer_config"}),(0,s.jsx)(t.td,{children:"WriterOutputConfig"}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The configuration for the output writer and which details to store."})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"WriterOutputConfig contains only the EnhancedMetricsConfig, as below."}),"\n",(0,s.jsx)(t.h4,{id:"enhancedmetricsconfig",children:"EnhancedMetricsConfig"}),"\n",(0,s.jsxs)(t.p,{children:["The Enhanced Metrics Config is used to configure the ",(0,s.jsx)(t.em,{children:"Network Performance Metrics Enhanced"})," table and what values will be stored in it."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populate_enhanced_metrics"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to populate enhanced metrics."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populate_enhanced_metrics_profile"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"False"}),(0,s.jsx)(t.td,{children:"Whether to populate enhanced metrics profiles."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populate_duration_curves"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to populate duration curves."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populate_constraints"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to populate constraints."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"populate_weekly_reports"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to populate weekly reports."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculate_normal_for_load_thermal"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to calculate normal values for load thermal."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculate_emerg_for_load_thermal"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to calculate emergency values for load thermal."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculate_normal_for_gen_thermal"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to calculate normal values for generator thermal."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculate_emerg_for_gen_thermal"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to calculate emergency values for generator thermal."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"calculate_co2"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsx)(t.td,{children:"Whether to calculate CO\u2082 cost values."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"storedresultsconfig",children:"StoredResultsConfig"}),"\n",(0,s.jsx)(t.p,{children:"The Stored Results Config controls the raw results that will be stored."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Variable Name"}),(0,s.jsx)(t.th,{children:"Data Type"}),(0,s.jsx)(t.th,{children:"Default"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energy_meter_voltages_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"False"}),(0,s.jsxs)(t.td,{children:["Store the Output Table ",(0,s.jsx)(t.em,{children:"Energy Meter Voltages Raw"}),"](../reference/output-tables#energy-meter-voltages-raw)."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"energy_meters_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"False"}),(0,s.jsxs)(t.td,{children:["Store the table ",(0,s.jsx)(t.a,{href:"../reference/output-tables#energy-meters-raw",children:"Energy Meters Raw"}),"."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"overloads_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"True"}),(0,s.jsxs)(t.td,{children:["Store the table ",(0,s.jsx)(t.a,{href:"../reference/output-tables#overloads-raw",children:"Overloads Raw"}),"."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"voltage_exceptions_raw"}),(0,s.jsx)(t.td,{children:"bool"}),(0,s.jsx)(t.td,{children:"False"}),(0,s.jsxs)(t.td,{children:["Store the table ",(0,s.jsx)(t.a,{href:"../reference/output-tables#voltage-exceptions-raw",children:"Voltage Exceptions Raw"}),"."]})]})]})]}),"\n",(0,s.jsx)(t.admonition,{title:"note",type:"caution",children:(0,s.jsx)(t.p,{children:"Storing raw results will utilise a lot of storage space and should be done only very carefully, and likely avoided for large Work Packages."})}),"\n",(0,s.jsx)(t.h3,{id:"metricsresultsconfig",children:"MetricsResultsConfig"}),"\n",(0,s.jsxs)(t.p,{children:["The Metrics Results Config controls the basic (and semi-depreciated) ",(0,s.jsx)(t.em,{children:"Network Performance Metrics"})," table. It contains a single boolean value to determine whether to populate the table."]})]})}function x(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8127:function(e,t,r){r.d(t,{A:()=>i});var n=r(4848),s=r(6540);function i(e){let{title:t,children:r,id:i,isExpandedAll:o}=e,[l,d]=(0,s.useState)(!1),[a,c]=(0,s.useState)(!1);return(0,s.useEffect)(()=>{null!=o&&d(o)},[o]),(0,s.useEffect)(()=>{let e=()=>{c("dark"===document.documentElement.dataset.theme)};e();let t=new MutationObserver(e);return t.observe(document.documentElement,{attributes:!0,attributeFilter:["data-theme"]}),()=>t.disconnect()},[]),(0,n.jsxs)("div",{className:"white-background",style:{marginBottom:"1em",backgroundColor:a?"#18191A":void 0,color:a?"#e0e0e0":void 0},children:[(0,n.jsxs)("div",{onClick:()=>d(!l),style:{cursor:"pointer",fontWeight:"bold",marginBottom:"0.5em",backgroundColor:a?"#2a3b4d":"#c3e9f7",color:a?"#fff":"#000",padding:"0.5em",borderRadius:"6px"},children:[t," ",l?"\u25B2":"\u25BC"]}),l&&(0,n.jsx)("div",{children:r})]})}},4429:function(e,t,r){r.d(t,{R:()=>o,x:()=>l});var n=r(6540);let s={},i=n.createContext(s);function o(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);