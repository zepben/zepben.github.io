"use strict";(self.webpackChunkhosting_capacity_service=self.webpackChunkhosting_capacity_service||[]).push([["1092"],{637:function(e,t,i){i.r(t),i.d(t,{frontMatter:()=>o,toc:()=>d,default:()=>h,metadata:()=>n,assets:()=>l,contentTitle:()=>s});var n=JSON.parse('{"id":"how-to-guides/calibration","title":"How to run Network Model Calibration","description":"This page provides a guide for network model calibration within the Hosting Capacity Module. It yields a table of tap settings for each off-load transformer, which can then be used in future work packages to run time-series modelling with the inferred tap positions. It also produces a set of raw results per energy consumer highlighting modelled (simulated) and measured (real) voltages, which can be used to highlight impedance errors in the model and for validation analysis.","source":"@site/docs/how-to-guides/calibration.mdx","sourceDirName":"how-to-guides","slug":"/how-to-guides/calibration","permalink":"/evolve/docs/hosting-capacity-service/next/how-to-guides/calibration","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"calibration","title":"How to run Network Model Calibration","slug":"/how-to-guides/calibration","toc_max_heading_level":4},"sidebar":"theSidebar","previous":{"title":"How to install Python","permalink":"/evolve/docs/hosting-capacity-service/next/how-to-guides/install-python"},"next":{"title":"How to run Feeder Load Analysis","permalink":"/evolve/docs/hosting-capacity-service/next/how-to-guides/feeder-load-analysis"}}'),a=i(4848),r=i(4429);let o={id:"calibration",title:"How to run Network Model Calibration",slug:"/how-to-guides/calibration",toc_max_heading_level:4},s="How to Run Network Model Calibration",l={},d=[{value:"What time to pick",id:"what-time-to-pick",level:2},{value:"Recommended Option",id:"recommended-option",level:2},{value:"Using the Hosting Capacity Runner tool",id:"using-the-hosting-capacity-runner-tool",level:3},{value:"Using the EAS Client Python Library",id:"using-the-eas-client-python-library",level:3},{value:"Using GraphQL",id:"using-graphql",level:3},{value:"Calibration results",id:"calibration-results",level:2},{value:"Tap settings",id:"tap-settings",level:3},{value:"Raw Results",id:"raw-results",level:3}];function c(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"how-to-run-network-model-calibration",children:"How to Run Network Model Calibration"})}),"\n",(0,a.jsx)(t.p,{children:"This page provides a guide for network model calibration within the Hosting Capacity Module. It yields a table of tap settings for each off-load transformer, which can then be used in future work packages to run time-series modelling with the inferred tap positions. It also produces a set of raw results per energy consumer highlighting modelled (simulated) and measured (real) voltages, which can be used to highlight impedance errors in the model and for validation analysis."}),"\n",(0,a.jsx)(t.h1,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"../how-to-guides/run-a-work-package",children:"How to Run a Work Package"})," guide for prerequisites on basic Work Package setup, which are similar for running Network Model Calibration."]}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"../reference/calibration-methodology",children:"Model Calibration Methodology"})," page for a detailed overview of the calibration process, including data requirements."]}),"\n",(0,a.jsx)(t.h2,{id:"what-time-to-pick",children:"What time to pick"}),"\n",(0,a.jsx)(t.p,{children:"Calibration can be used for two related but distinct things:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Determining a best fit for off-load tap settings (the ",(0,a.jsx)(t.code,{children:"calibrated_taps"})," table) to use in HCM Work Packages\nFor this use case, it will work best using a time of minimum load. This may vary by network, but is typically around 4am."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Measuring raw results per energy consumer, highlighting modelled (simulated) and measured (real) voltages, which can be used to highlight impedance errors in the model and for further analysis.\nFor this use case, you may want to try a number of different conditions, for periods such as 7am, 12pm, 7pm, and 4am could be useful to explore periods of medium demand, high generation, high demand, and low demand respectively."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"Make sure the time you specify has available PQV data in the database, otherwise the calibration will not run successfully. Not all times will have PQV data available, and will depend on the data you have ingested into the system. To see details of how the PQV data was used, see the logs for detailed information on an individual calibration run. Only some logs are available in the front end, contact Zepben support if you need further information."})}),"\n",(0,a.jsx)(t.h1,{id:"how-to-run",children:"How to Run"}),"\n",(0,a.jsx)(t.h2,{id:"recommended-option",children:"Recommended Option"}),"\n",(0,a.jsx)(t.h3,{id:"using-the-hosting-capacity-runner-tool",children:"Using the Hosting Capacity Runner tool"}),"\n",(0,a.jsx)(t.p,{children:"The Hosting Capacity Runner tool provides a user interface to run Network Model Calibration."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Clone the ",(0,a.jsx)(t.a,{href:"https://github.com/Zepben/hosting-capacity-runner",children:"Hosting Capacity Runner"})," repository. Ensure requirements are installed by running ",(0,a.jsx)(t.code,{children:"pip install -r requirements.txt"}),". Check the ",(0,a.jsx)(t.code,{children:"README.md"})," and ensure other prerequisites are as per the general ",(0,a.jsx)(t.a,{href:"../how-to-guides/run-a-work-package",children:"Hosting Capacity Module prerequisites"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Open the ",(0,a.jsx)(t.code,{children:"run_calibration.py"})," file in the ",(0,a.jsx)(t.code,{children:"hosting_capacity_runner"})," directory."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Update the ",(0,a.jsx)(t.code,{children:"calibration_name"}),", ",(0,a.jsx)(t.code,{children:"calibration_time_local"}),", ",(0,a.jsx)(t.code,{children:"feeder_mrids"})," parameters in the script to match your requirements. Note that the time is the local time of the calibration in ISO 8601 format (it should not have a timezone offset, as the calibration time is assumed to be in the local timezone of the network model, which is set up in the underlying model). To run calibration for all feeders in the network, see the note in the file."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"Only one set of tap settings can be used on a given HCM Work Package. When running a Work Package, ensure you use the calibration results that include all feeders present in the Work Package"})}),"\n",(0,a.jsxs)(t.p,{children:["3a. If you want to use a set of off-load transformer tap settings from a previous calibration run (as you are interested in the voltage difference with the new taps), then uncomment the ",(0,a.jsx)(t.code,{children:"transformer_tap_settings"})," line and use the ",(0,a.jsx)(t.code,{children:"calibration_name"})," used previously as the value."]}),"\n",(0,a.jsxs)(t.p,{children:["3b. If you want to use a full ",(0,a.jsx)(t.code,{children:"generator_config"}),", you can directly copy-and-paste it from your standard 'run Work Package' file into the ",(0,a.jsx)(t.code,{children:"generator_config"})," section, being sure to get the bracketing correct."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["Note that the calibration workflow will always ignore certain parameters in the generator_config. Leaving them in will cause no issues, they will simply be ignored in favour of the values needed to make calibration work. These values are:\n",(0,a.jsx)(t.code,{children:"calibration"}),", ",(0,a.jsx)(t.code,{children:"meter_placement_config"}),", ",(0,a.jsx)(t.code,{children:"step_size_minutes"}),", and ",(0,a.jsx)(t.code,{children:"raw_results"}),"."]})}),"\n",(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsxs)(t.p,{children:["If a ",(0,a.jsx)(t.code,{children:"transformer_tap_settings"})," is provided directly, it will take precedence over any ",(0,a.jsx)(t.code,{children:"transformer_tap_settings"})," supplied inside the ",(0,a.jsx)(t.code,{children:"generator_config"})," parameter."]}),(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Run the script using your IDE."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["To check the status of the Calibration Run, you can use the ",(0,a.jsx)(t.code,{children:"monitor_calibration_run.py"})," function in the same directory, using the ",(0,a.jsx)(t.code,{children:"calibration_id"})," returned by the ",(0,a.jsx)(t.code,{children:"run_calibration.py"})," script."]}),"\n"]}),"\n"]}),(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.em,{children:"Calibration Run"})," is the whole end-to-end process of Network Model Calibration, of which a ",(0,a.jsx)(t.em,{children:"Calibration Work Package"})," is one part. The ",(0,a.jsx)(t.em,{children:"Calibration Work Package"})," is the actual load flow simulation to produce raw results. The ",(0,a.jsx)(t.em,{children:"Calibration Run"})," includes the setup, the ",(0,a.jsx)(t.em,{children:"Calibration Work Package"}),", and the post-processing to produce the calibrated tap settings table. In typical workflows, these may not need to be distinguished from each other, but at a technical level, for testing, debugging and verification, it is important to understand the distinction. If there are issues then it is possible that the ",(0,a.jsx)(t.em,{children:"Work Package"})," may have completed but the overall ",(0,a.jsx)(t.em,{children:"Calibration Run"})," may have failed in post-processing and so not have produced the tap settings table. Consult Zepben with any questions."]})})]}),"\n",(0,a.jsx)(t.h1,{id:"alternative-methods",children:"Alternative Methods"}),"\n",(0,a.jsx)(t.h3,{id:"using-the-eas-client-python-library",children:"Using the EAS Client Python Library"}),"\n",(0,a.jsxs)(t.p,{children:["If you prefer to use the EAS Client Python Library directly, you can run Model Calibration using the ",(0,a.jsx)(t.code,{children:"run_hosting_capacity_calibration"})," method."]}),"\n",(0,a.jsxs)(t.p,{children:["In the ",(0,a.jsx)(t.code,{children:"eas-client-python"})," client, run:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'run_hosting_capacity_calibration(`calibration_name`, `local_calibration_time`,["`feeder1`", "`feeder2`", "`feeder3etc`"], `transformer_tap_settings`, `generator_config`)\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This will start a Model Calibration run with the specified name, time and feeders. ",(0,a.jsx)(t.code,{children:"transformer_tap_settings"})," and ",(0,a.jsx)(t.code,{children:"generator_config"})," are optional, see above for more info."]}),"\n",(0,a.jsx)(t.h3,{id:"using-graphql",children:"Using GraphQL"}),"\n",(0,a.jsx)(t.p,{children:"Run a GraphQL query to start Network Model Calibration."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:'mutation {runCalibration(calibrationName: "tap_settings_42", calibrationTimeLocal: "2025-01-15T00:00:00" , feeders: ["feeder1", "feeder2", "feeder3etc"], generatorConfig: {\nmodel: {\n        load_vmax_pu=1.2,\n        etc. \n       }\n  }\n)\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This will start a Model Calibration run."}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"The QraphQL doesn't have a separate argument for the transformer tap settings. That must be set by providing a generatorConfig."})}),"\n",(0,a.jsx)(t.h2,{id:"calibration-results",children:"Calibration results"}),"\n",(0,a.jsx)(t.p,{children:"Calibration produces two main outputs:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"A table of tap settings for each off-load transformer, which can then be used in future work packages to run time-series modelling with the inferred tap positions."}),"\n",(0,a.jsx)(t.li,{children:"A set of raw results per energy consumer highlighting modelled (simulated) and measured (real) voltages, which can be used to highlight impedance errors in the model and for validation analysis."}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"If you pass a set of transformer tap settings into the calibration run (via the direct parameter or via a generator config), the calibration run will not not produce a new set of tap settings, as it is assumed you are interested in the voltage difference with the new taps. In this case, only the raw results will be produced."})}),"\n",(0,a.jsx)(t.h3,{id:"tap-settings",children:"Tap settings"}),"\n",(0,a.jsxs)(t.p,{children:["The tap settings from a calibration run are stored in the ",(0,a.jsx)(t.em,{children:"input"})," database (input as they form part of the ",(0,a.jsx)(t.em,{children:"inputs"})," to a regular Work Package), in a table called ",(0,a.jsx)(t.code,{children:"calibrated_taps"}),". See the Calibrated Taps Table in the ",(0,a.jsx)(t.a,{href:"../reference/input-tables",children:"Input Tables"})," section for a full breakdown. These can then be called by their unique name in a Work Package config for use in that Work Package."]}),"\n",(0,a.jsx)(t.h3,{id:"raw-results",children:"Raw Results"}),"\n",(0,a.jsxs)(t.p,{children:["The raw results of the calibration run are stored in the ",(0,a.jsx)(t.code,{children:"calibration_meter_results"})," table, which is stored in the results / outputs database. See the Calibration Meter results in the ",(0,a.jsx)(t.a,{href:"../reference/output-tables",children:"Output Tables"})," section for a full breakdown."]}),"\n",(0,a.jsxs)(t.p,{children:["For more info see the ",(0,a.jsx)(t.a,{href:"../reference/calibration-methodology",children:"Model Calibration Methodology"})," page, which provides a detailed overview of the calibration process, including data ingestion, model adjustments, load flow execution, and off-load tap position determination."]}),"\n",(0,a.jsxs)(t.p,{children:["And the ",(0,a.jsx)(t.a,{href:"../explanation/calibration-concepts",children:"What is Network Model Calibration and why is it useful?"})," page for an overview of the concepts behind network model calibration, its importance, and how it can be applied to improve the accuracy of power system models."]})]})}function h(e={}){let{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},4429:function(e,t,i){i.d(t,{R:()=>o,x:()=>s});var n=i(6540);let a={},r=n.createContext(a);function o(e){let t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);