"use strict";(self.webpackChunkhosting_capacity_service_doco=self.webpackChunkhosting_capacity_service_doco||[]).push([[26],{5680:(e,t,a)=>{a.d(t,{xA:()=>u,yg:()=>y});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var g=n.createContext({}),d=function(e){var t=n.useContext(g),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(g.Provider,{value:t},e.children)},s="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,g=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),s=d(a),m=r,y=s["".concat(g,".").concat(m)]||s[m]||p[m]||l;return a?n.createElement(y,o(o({ref:t},u),{},{components:a})):n.createElement(y,o({ref:t},u))}));function y(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=m;var i={};for(var g in t)hasOwnProperty.call(t,g)&&(i[g]=t[g]);i.originalType=e,i[s]="string"==typeof e?e:r,o[1]=i;for(var d=2;d<l;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7338:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>g,default:()=>y,frontMatter:()=>i,metadata:()=>d,toc:()=>s});var n=a(8168),r=a(8587),l=(a(6540),a(5680));const o=["components"],i={id:"configuration",title:"Configuration",slug:"/reference/configuration",hide_table_of_contents:!0},g="Work Package Configuration Options",d={unversionedId:"reference/configuration",id:"reference/configuration",title:"Configuration",description:"There are various elements that must be configured to successfully create a OpenDSS model from the input data, which are then used to run a Hosting Capacity Model work package.",source:"@site/docs/reference/configuration.mdx",sourceDirName:"reference",slug:"/reference/configuration",permalink:"/evolve/docs/hosting-capacity-service/docs/next/reference/configuration",draft:!1,tags:[],version:"current",frontMatter:{id:"configuration",title:"Configuration",slug:"/reference/configuration",hide_table_of_contents:!0},sidebar:"theSidebar",previous:{title:"Output Tables",permalink:"/evolve/docs/hosting-capacity-service/docs/next/reference/output-tables"},next:{title:"Model Calibration Methodology",permalink:"/evolve/docs/hosting-capacity-service/docs/next/reference/calibration-methodology"}},u={},s=[{value:"Example",id:"example",level:3},{value:"ForecastConfig",id:"forecastconfig",level:3},{value:"Example",id:"example-1",level:4},{value:"Model Config Parameters",id:"model-config-parameters",level:2},{value:"Solve Config",id:"solve-config",level:3},{value:"Raw Results Config",id:"raw-results-config",level:3},{value:"ResultProcessorConfig",id:"resultprocessorconfig",level:2},{value:"WriterConfig",id:"writerconfig",level:3},{value:"EnhancedMetricsConfig",id:"enhancedmetricsconfig",level:3},{value:"StoredResultsConfig",id:"storedresultsconfig",level:3},{value:"MetricsResultsConfig",id:"metricsresultsconfig",level:3}],p={toc:s},m="wrapper";function y(e){let{components:t}=e,a=(0,r.A)(e,o);return(0,l.yg)(m,(0,n.A)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.yg)("h1",{id:"work-package-configuration-options"},"Work Package Configuration Options"),(0,l.yg)("p",null,"There are various elements that must be configured to successfully create a OpenDSS model from the input data, which are then used to run a Hosting Capacity Model work package.\nThis page describes the configuration options available in running a Work Package via the Python API."),(0,l.yg)("h3",{id:"example"},"Example"),(0,l.yg)("p",null,"Here is an example of a work package config:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-WorkPackageConfig"},'  WorkPackageConfig(\n            name=config["work_package_name"],\n            syf_config=forecast_config,\n            generator_config=GeneratorConfig(\n                model=ModelConfig(\n                    vmax_pu=1.2,\n                    vmin_pu=0.8,\n                    p_factor_base_exports=-1,\n                    p_factor_base_imports=1,\n                    p_factor_forecast_pv=1,\n                    fix_single_phase_loads=False,\n                    max_single_phase_load=15000.0,\n                    max_load_service_line_ratio=1.0,\n                    max_load_lv_line_ratio=2.0,\n                    max_load_tx_ratio=2.0,\n                    max_gen_tx_ratio=4.0,\n                    fix_overloading_consumers=True,\n                    fix_undersized_service_lines=True,\n                    feeder_scenario_allocation_strategy=FeederScenarioAllocationStrategy.ADDITIVE,\n                    closed_loop_v_reg_enabled=False,\n                    closed_loop_v_reg_set_point=0.9925,\n                    seed=123,\n                ),\n                solve=SolveConfig(step_size_minutes=30.0),\n                raw_results=RawResultsConfig(True, True, True, True, True)\n            ),\n\n            result_processor_config=ResultProcessorConfig(\n                writer_config=WriterConfig(\n                    output_writer_config=WriterOutputConfig(\n                        enhanced_metrics_config=EnhancedMetricsConfig(\n                            True,\n                            False,\n                            True,\n                            True,\n                            True,\n                            True,\n                            True,\n                            True,\n                            True,\n                            True,\n                        ))),\n                stored_results=StoredResultsConfig(False, False, True, False),\n                metrics=MetricsResultsConfig(True)\n            ),\n            quality_assurance_processing=True\n        )\n    )\n')),(0,l.yg)("h3",{id:"forecastconfig"},"ForecastConfig"),(0,l.yg)("h4",{id:"example-1"},"Example"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre"},'forecast_config = ForecastConfig(\n        feeders=config["feeders"],\n        years=config["forecast_years"],\n        scenarios=config["scenarios"],\n        load_time=TimePeriod(\n            start_time=datetime.fromisoformat(config["load_time"]["start1"]),\n            end_time=datetime.fromisoformat(config["load_time"]["end1"]),\n        )\n    )\n')),(0,l.yg)("p",null,"This ForecastConfig object is used to define the forecast parameters for the work package. It includes the feeders to be used, the years for which the forecast is applicable, the scenarios to be considered, and the time period for load data. It uses the config.json file to set these parameters. "),(0,l.yg)("p",null,"Here is an example of a sample config.json file that can be used to create the ForecastConfig object:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "work_package_name": "test_work_package",\n  "feeders": [\n    "feeder1", "feeder2", "feeder3"\n  ],\n  "load_time": {\n    "start1": "2023-02-22T00:00:00.00Z",\n    "end1": "2024-02-22T00:00:00.00Z",\n  },\n  "forecast_years": [\n    2024\n  ],\n  "scenarios": [\n    "base"\n  ]\n}\n')),(0,l.yg)("h1",{id:"work-package-config"},"Work Package Config"),(0,l.yg)("p",null,"The Work Package Config is the main configuration object that contains all the necessary configurations for running a Hosting Capacity Model work package. It includes the forecast configuration, generator configuration, result processor configuration, and quality assurance processing flag (quality_assurance_processing)."),(0,l.yg)("h2",{id:"model-config-parameters"},"Model Config Parameters"),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"vmin_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"0.80"),(0,l.yg)("td",{parentName:"tr",align:null},"Minimum per unit voltage for which the load model selected and generator model is assumed to apply. Below this value, the load/gen model reverts to a constant impedance model.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"vmax_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"1.15"),(0,l.yg)("td",{parentName:"tr",align:null},"Maximum per unit voltage for which the load model selected and generator model is assumed to apply. Above this value, the load/gen model reverts to a constant impedance model.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"load_model"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"1"),(0,l.yg)("td",{parentName:"tr",align:null},"Load/generator modeling mode (1 to 7): Specifies how loads and generators in OpenDSS should be modelled. Options: ",(0,l.yg)("br",null)," 1: Standard constant P+jQ load. (Default) ",(0,l.yg)("br",null)," 2: Constant impedance load. ",(0,l.yg)("br",null)," 3: Const P, Quadratic Q (like a motor). ",(0,l.yg)("br",null)," 4: Nominal Linear P, Quadratic Q (feeder mix). Use this with CVRfactor. ",(0,l.yg)("br",null)," 5: Constant Current Magnitude ",(0,l.yg)("br",null)," 6: Const P, Fixed Q ",(0,l.yg)("br",null)," 7: Const P, Fixed Impedance Q.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"collapse_swer"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"false"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to collapse/simplify SWER network.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calibration"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"false"),(0,l.yg)("td",{parentName:"tr",align:null},"Apply calibration using PQV data.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"p_factor_base_exports"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"Power factor for base model generators. If ",(0,l.yg)("inlineCode",{parentName:"td"},"null")," the model will use the reactive power specified in the load profiles.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"p_factor_forecast_pv"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"1.0"),(0,l.yg)("td",{parentName:"tr",align:null},"Power factor to set for scenario (forecast) model Generators during model translation.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"p_factor_base_imports"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"Power factor to set for base model Loads during model translation. If null the model will use the reactive power specified in the load profiles.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"fix_single_phase_loads"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"true"),(0,l.yg)("td",{parentName:"tr",align:null},"Finds consumers with a peak load (within the modelled time period) greater than the configured max_single_phase_load value. ",(0,l.yg)("br",null)," Upgrades these consumers to three-phase loads to correct data inaccuracies in reported phase numbers. ",(0,l.yg)("br",null)," Traces upstream to the distribution transformer and spreads 3 phases (ABCN) back to the transformer where possible.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_single_phase_load"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"30000.0"),(0,l.yg)("td",{parentName:"tr",align:null},"The max peak load for a single phase customer, beyond which will trigger the single phase load fixing algorithm mentioned above.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"fix_overloading_consumers"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"true"),(0,l.yg)("td",{parentName:"tr",align:null},"Finds consumers that have peak load or generation (within the modelled time period) greater than the capacity of the transformer they are attached to by a configurable factor, and then reconfigures them to be HV consumers (attached above the transformer). The aim is to identify HV consumers that have been incorrectly connected as LV consumers, and resolve this connectivity.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_load_tx_ratio"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"3.0"),(0,l.yg)("td",{parentName:"tr",align:null},"The maximum load to transformer rating ratio for a single consumer to trigger the overloading consumer fixer. For a ratio of 2, if a customer with a peak 30kW load was downstream of a 10kVA transformer, this would be a ratio of 3:1 and thus trigger the overloading consumers fixer.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_gen_tx_ratio"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"10.0"),(0,l.yg)("td",{parentName:"tr",align:null},"The maximum generation to transformer rating ratio for a single consumer to trigger the overloading consumer fixer. For a ratio of 2, if a customer with peak generation of 30kW was downstream of a 10kVA transformer, this would be a ratio of 3:1 and thus trigger the overloading consumers fixer.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"fix_undersized_service_lines"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"true"),(0,l.yg)("td",{parentName:"tr",align:null},"Finds consumers that have a peak load (within the modelled time period) greater than the capacity of the service line of the consumer by a configured factor. The intent is to find service lines that have unrealistically low current ratings which would stop convergence, and upgrade them to sensible ratings. When a conductors rating is upgraded, the impedance is also upgraded to match, utilising a pre-configured catalogue of rating and impedance data, and matching the phase configuration of the consumer.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_load_service_line_ratio"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"1.5"),(0,l.yg)("td",{parentName:"tr",align:null},"The maximum load to service line rating ratio to trigger the undersized service lines fixer. For example given a ratio of 2, if a customer with peak load of 10kW had a service line supporting only 5kVA, this would be a ratio of 2:1 and thus trigger the undersized service line fixer. Note: service lines are generally considered to be the conductors immediately connecting to a consumer.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_load_lv_line_ratio"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"2.0"),(0,l.yg)("td",{parentName:"tr",align:null},"The maximum load to LV line rating ratio to trigger the undersized service lines fixer for LV conductors. For example given a ratio of 5, if a customer with peak load of 50kW was connected to LV backbone conductors supporting only 10kVA, this would be a ratio of 5:1 and thus trigger the undersized service line fixer for the LV conductors. Note the LV line fixer will fix all conductors upstream of the consumer up to the distribution transformer they are connected to.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"collapse_lv_networks"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"false"),(0,l.yg)("td",{parentName:"tr",align:null},"Flag to control whether to collapse lv network in the model.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"feeder_scenario_allocation_strategy"),(0,l.yg)("td",{parentName:"tr",align:null},"str"),(0,l.yg)("td",{parentName:"tr",align:null},"ADDITIVE"),(0,l.yg)("td",{parentName:"tr",align:null},"Strategy for scenario ev, pv and bess allocation. ADDITIVE will be each year is built upon the last years allocation, while RANDOM will be a different allocation every year")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_v_reg_enabled"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"true"),(0,l.yg)("td",{parentName:"tr",align:null},"Create models with a Closed Loop Voltage Regulator at the Zone sub. If false, existing voltage regulator's in the zone sub will be used.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_v_reg_replace_all"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"true"),(0,l.yg)("td",{parentName:"tr",align:null},"Replace all existing Voltage Regulators with Closed Loop Voltage Regulator. If false existing zone sub regulators will be modelled as-is which may be in non-closed loop configuration.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_v_reg_set_point"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"0.985"),(0,l.yg)("td",{parentName:"tr",align:null},"Scaling factor for the base voltage to form the set  point (0.0-2.0).")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_v_band"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"2.0"),(0,l.yg)("td",{parentName:"tr",align:null},"VBand value in percentage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_time_delay"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"100"),(0,l.yg)("td",{parentName:"tr",align:null},"Time delay in seconds (for closed loop control)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"closed_loop_v_limit"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"1.1"),(0,l.yg)("td",{parentName:"tr",align:null},"Maximum voltage at regulating transformer's secondary bus.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_tap_changer_time_delay"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"100"),(0,l.yg)("td",{parentName:"tr",align:null},"Tap changer time delay (seconds).")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_tap_changer_set_point_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"1.0"),(0,l.yg)("td",{parentName:"tr",align:null},"Tap changer set point.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_tap_changer_band"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"2.0"),(0,l.yg)("td",{parentName:"tr",align:null},"Tap changer band value.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"split_phase_default_load_loss_percentage"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"0.4"),(0,l.yg)("td",{parentName:"tr",align:null},"Load loss % for split-phase transformers.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"split_phase_lv_kv"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"0.25"),(0,l.yg)("td",{parentName:"tr",align:null},"Split phase LV voltage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"swer_voltage_to_line_voltage"),(0,l.yg)("td",{parentName:"tr",align:null},"List[List","[int]","]"),(0,l.yg)("td",{parentName:"tr",align:null},"230 to 400  ",(0,l.yg)("br",null)," 240 to 415  ",(0,l.yg)("br",null)," 250 to 433  ",(0,l.yg)("br",null)," 6350 to 11000  ",(0,l.yg)("br",null)," 6400 to 11000  ",(0,l.yg)("br",null)," 12700 to 22000  ",(0,l.yg)("br",null)," 19100 to 33000"),(0,l.yg)("td",{parentName:"tr",align:null},"Mapping SWER voltages to line-to-line.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"load_placement"),(0,l.yg)("td",{parentName:"tr",align:null},"LoadPlacement"),(0,l.yg)("td",{parentName:"tr",align:null},"PER_USAGE_POINT"),(0,l.yg)("td",{parentName:"tr",align:null},"Create loads per UsagePoint (PER_ENERGY_CONSUMER) or EnergyConsumer (PER_ENERGY_CONSUMER)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"load_interval_length_hours"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"0.5"),(0,l.yg)("td",{parentName:"tr",align:null},"Load interval in fractions of an hour, 1.0 = 60 minute intervals, 0.5 = 30 minute intervals")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"meter_placement_config"),(0,l.yg)("td",{parentName:"tr",align:null},"MeterPlacementConfig"),(0,l.yg)("td",{parentName:"tr",align:null},"MeterPlacementConfig()"),(0,l.yg)("td",{parentName:"tr",align:null},"Configuration to determine where to place EnergyMeters for collecting results")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"seed"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"A seed to use when generating the model. Re-using the same seed will result in the same model being generated.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_load_watts"),(0,l.yg)("td",{parentName:"tr",align:null},"List","[float]"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"A list of readings to be used as default load watts when no load data is found. Can be either a yearly or daily profile. . The number of entries must correspond to the configured load_interval_length_hours, eg for 0.5: 48 entries for daily and 17520 for yearly, etc")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_gen_watts"),(0,l.yg)("td",{parentName:"tr",align:null},"List","[float]"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"A list of readings to be used as default gen watts when no load data is found. Can be either a yearly or daily profile. The number of entries must correspond to the configured load_interval_length_hours.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_load_var"),(0,l.yg)("td",{parentName:"tr",align:null},"List","[float]"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"A list of readings to be used as default load var when no load data is found. Can be either a yearly or daily profile. The number of entries must correspond to the configured load_interval_length_hours.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"default_gen_var"),(0,l.yg)("td",{parentName:"tr",align:null},"List","[float]"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"A list of readings to be used as default gen var when no load data is found. Can be either a yearly or daily profile. The number of entries must correspond to the configured load_interval_length_hours.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"transformer_tap_settings"),(0,l.yg)("td",{parentName:"tr",align:null},"str"),(0,l.yg)("td",{parentName:"tr",align:null},"None"),(0,l.yg)("td",{parentName:"tr",align:null},"The name of the set of distribution transformer tap settings to be applied to the model from an external source.")))),(0,l.yg)("h3",{id:"solve-config"},"Solve Config"),(0,l.yg)("p",null,"The Solve config related to options used in the OpenDSS model."),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"norm_vmin_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Normal minimum per unit voltage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"norm_vmax_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Normal maximum per unit voltage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"emerg_vmin_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Emergency minimum per unit voltage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"emerg_vmax_pu"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Emergency maximum per unit voltage.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"base_frequency"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"50"),(0,l.yg)("td",{parentName:"tr",align:null},"Base frequency for the simulation.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"voltage_bases"),(0,l.yg)("td",{parentName:"tr",align:null},"List","[float]"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"List of voltage base values.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_iter"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Max iterations before failing.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"max_control_iter"),(0,l.yg)("td",{parentName:"tr",align:null},"int"),(0,l.yg)("td",{parentName:"tr",align:null},"??"),(0,l.yg)("td",{parentName:"tr",align:null},"Max control iterations before failing.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"mode"),(0,l.yg)("td",{parentName:"tr",align:null},"str"),(0,l.yg)("td",{parentName:"tr",align:null},"YEARLY"),(0,l.yg)("td",{parentName:"tr",align:null},"Run OpenDSS in YEARLY or DAILY mode.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"step_size_minutes"),(0,l.yg)("td",{parentName:"tr",align:null},"float"),(0,l.yg)("td",{parentName:"tr",align:null},"30"),(0,l.yg)("td",{parentName:"tr",align:null},"The step size for the solver in minutes.")))),(0,l.yg)("h3",{id:"raw-results-config"},"Raw Results Config"),(0,l.yg)("p",null,"Whether to produce raw results generated from OpenDSS. You will likely always want defaults for this, as setting any of these to False will limit the results you get and should only be used as a potential performance optimisation if they are unnecessary."),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"energy_meter_voltages_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Produce energy meter voltages results.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"energy_meters_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Produce energy meter results.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"results_per_meter"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Produce results per EnergyMeter.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"overloads_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Produce overloads.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"voltage_exceptions_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Produce voltage exceptions.")))),(0,l.yg)("h2",{id:"resultprocessorconfig"},"ResultProcessorConfig"),(0,l.yg)("p",null,"The Result Processor Config is used to configure how the results of the work package are processed and stored. Includes sub-configs; WriterConfig (containing the WriterOutputConfig, which itself contains the EnhancedMetricsConfig), the StoredResultsConfig and MetricsResultsConfig."),(0,l.yg)("h3",{id:"writerconfig"},"WriterConfig"),(0,l.yg)("p",null,"The Writer Config is used to configure how the results of the work package are written. It includes the type of writer (Postgres or Parquet) and the configuration for the output writer."),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"writer_type"),(0,l.yg)("td",{parentName:"tr",align:null},"WriterType"),(0,l.yg)("td",{parentName:"tr",align:null},"POSTGRES or PARQUET"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to write output to Parquet files or a Postgres database. Check with your administrator which result types are supported.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"output_writer_config"),(0,l.yg)("td",{parentName:"tr",align:null},"WriterOutputConfig"),(0,l.yg)("td",{parentName:"tr",align:null}),(0,l.yg)("td",{parentName:"tr",align:null},"The configuration for the output writer and which details to store.")))),(0,l.yg)("p",null,"WriterOutputConfig contains only the EnhancedMetricsConfig"),(0,l.yg)("h3",{id:"enhancedmetricsconfig"},"EnhancedMetricsConfig"),(0,l.yg)("p",null,"The Enhanced Metrics Config is used to configure the ",(0,l.yg)("em",{parentName:"p"},"Network Performance Metrics Enhanced")," table and what values will be stored in it. "),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"populate_enhanced_metrics"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to populate enhanced metrics.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"populate_enhanced_metrics_profile"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"False"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to populate enhanced metrics profiles.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"populate_duration_curves"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to populate duration curves.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"populate_constraints"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to populate constraints.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"populate_weekly_reports"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to populate weekly reports.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calculate_normal_for_load_thermal"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to calculate normal values for load thermal.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calculate_emerg_for_load_thermal"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to calculate emergency values for load thermal.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calculate_normal_for_gen_thermal"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to calculate normal values for generator thermal.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calculate_emerg_for_gen_thermal"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to calculate emergency values for generator thermal.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"calculate_co2"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Whether to calculate CO\u2082 cost values.")))),(0,l.yg)("h3",{id:"storedresultsconfig"},"StoredResultsConfig"),(0,l.yg)("p",null,"The Stored Results Config controls the raw results that will be stored. "),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Variable Name"),(0,l.yg)("th",{parentName:"tr",align:null},"Data Type"),(0,l.yg)("th",{parentName:"tr",align:null},"Default"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"energy_meter_voltages_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"False"),(0,l.yg)("td",{parentName:"tr",align:null},"Store the raw EnergyMeter timeseries voltage results.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"energy_meters_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"False"),(0,l.yg)("td",{parentName:"tr",align:null},"Store the raw EnergyMeter timeseries results.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"overloads_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"True"),(0,l.yg)("td",{parentName:"tr",align:null},"Store the raw overload results.")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},"voltage_exceptions_raw"),(0,l.yg)("td",{parentName:"tr",align:null},"bool"),(0,l.yg)("td",{parentName:"tr",align:null},"False"),(0,l.yg)("td",{parentName:"tr",align:null},"Store the raw voltage exception results.")))),(0,l.yg)("admonition",{title:"note",type:"caution"},(0,l.yg)("p",{parentName:"admonition"},"Storing raw results will utilise a lot of storage space and should be done only very carefully, and likely avoided for large Work Packages.")),(0,l.yg)("h3",{id:"metricsresultsconfig"},"MetricsResultsConfig"),(0,l.yg)("p",null,"The Metrics Results Config controls the basic (and semi-depreciated) ",(0,l.yg)("em",{parentName:"p"},"Network Performance Metrics")," table. It contains a single boolean value to determine whether to populate the table."))}y.isMDXComponent=!0}}]);