"use strict";(self.webpackChunkzepben_commons_doco=self.webpackChunkzepben_commons_doco||[]).push([[8341],{1470:(e,a,t)=>{t.d(a,{A:()=>v});var n=t(8168),r=t(6540),s=t(53),o=t(3104),l=t(6347),i=t(7485),p=t(1682),h=t(9466);function m(e){return function(e){return r.Children.map(e,e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})}(e).map(e=>{let{props:{value:a,label:t,attributes:n,default:r}}=e;return{value:a,label:t,attributes:n,default:r}})}function u(e){const{values:a,children:t}=e;return(0,r.useMemo)(()=>{const e=null!=a?a:m(t);return function(e){const a=(0,p.X)(e,(e,a)=>e.value===a.value);if(a.length>0)throw new Error('Docusaurus error: Duplicate values "'+a.map(e=>e.value).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e},[a,t])}function d(e){let{value:a,tabValues:t}=e;return t.some(e=>e.value===a)}function g(e){let{queryString:a=!1,groupId:t}=e;const n=(0,l.W6)(),s=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:a,groupId:t});return[(0,i.aZ)(s),(0,r.useCallback)(e=>{if(!s)return;const a=new URLSearchParams(n.location.search);a.set(s,e),n.replace(Object.assign({},n.location,{search:a.toString()}))},[s,n])]}function c(e){const{defaultValue:a,queryString:t=!1,groupId:n}=e,s=u(e),[o,l]=(0,r.useState)(()=>function(e){var a;let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+n.map(e=>e.value).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(a=n.find(e=>e.default))?a:n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:a,tabValues:s})),[i,p]=g({queryString:t,groupId:n}),[m,c]=function(e){let{groupId:a}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(a),[n,s]=(0,h.Dv)(t);return[n,(0,r.useCallback)(e=>{t&&s.set(e)},[t,s])]}({groupId:n}),y=(()=>{const e=null!=i?i:m;return d({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)(()=>{y&&l(y)},[y]);return{selectedValue:o,selectValue:(0,r.useCallback)(e=>{if(!d({value:e,tabValues:s}))throw new Error("Can't select invalid tab value="+e);l(e),p(e),c(e)},[p,c,s]),tabValues:s}}var y=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:a,block:t,selectedValue:l,selectValue:i,tabValues:p}=e;const h=[],{blockElementScrollPositionUntilNextRender:m}=(0,o.a_)(),u=e=>{const a=e.currentTarget,t=h.indexOf(a),n=p[t].value;n!==l&&(m(a),i(n))},d=e=>{var a;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var n;const a=h.indexOf(e.currentTarget)+1;t=null!=(n=h[a])?n:h[0];break}case"ArrowLeft":{var r;const a=h.indexOf(e.currentTarget)-1;t=null!=(r=h[a])?r:h[h.length-1];break}}null==(a=t)||a.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},a)},p.map(e=>{let{value:a,label:t,attributes:o}=e;return r.createElement("li",(0,n.A)({role:"tab",tabIndex:l===a?0:-1,"aria-selected":l===a,key:a,ref:e=>h.push(e),onKeyDown:d,onClick:u},o,{className:(0,s.A)("tabs__item",f.tabItem,null==o?void 0:o.className,{"tabs__item--active":l===a})}),null!=t?t:a)}))}function N(e){let{lazy:a,children:t,selectedValue:n}=e;if(t=Array.isArray(t)?t:[t],a){const e=t.find(e=>e.props.value===n);return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},t.map((e,a)=>(0,r.cloneElement)(e,{key:a,hidden:e.props.value!==n})))}function w(e){const a=c(e);return r.createElement("div",{className:(0,s.A)("tabs-container",f.tabList)},r.createElement(b,(0,n.A)({},e,a)),r.createElement(N,(0,n.A)({},e,a)))}function v(e){const a=(0,y.A)();return r.createElement(w,(0,n.A)({key:String(a)},e))}},2385:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>u,contentTitle:()=>h,default:()=>y,frontMatter:()=>p,metadata:()=>m,toc:()=>d});var n=t(8168),r=t(8587),s=(t(6540),t(5680)),o=t(1470),l=t(9365);const i=["components"],p={id:"phase-consistency",title:"Phase Consistency Processor"},h=void 0,m={unversionedId:"phase-consistency",id:"version-1.1.1/phase-consistency",title:"Phase Consistency Processor",description:"The phase consistency module is used to repair phase inconsistencies in a NetworkService.",source:"@site/versioned_docs/version-1.1.1/phase-consistency.mdx",sourceDirName:".",slug:"/phase-consistency",permalink:"/evolve/docs/commons/1.1.1/phase-consistency",draft:!1,tags:[],version:"1.1.1",frontMatter:{id:"phase-consistency",title:"Phase Consistency Processor"},sidebar:"someSidebar",previous:{title:"Metrics for Issues",permalink:"/evolve/docs/commons/1.1.1/metrics-for-issues"},next:{title:"Phase Rebalance Processor",permalink:"/evolve/docs/commons/1.1.1/phase-rebalance"}},u={},d=[{value:"Quick Start",id:"quick-start",level:2},{value:"Repair the phases of any split 3-phase",id:"repair-the-phases-of-any-split-3-phase",level:2},{value:"Sub-processors",id:"sub-processors",level:2},{value:"LvSwitchPhaseRepairer",id:"lvswitchphaserepairer",level:3},{value:"DroppedPhaseLoopFixer",id:"droppedphaseloopfixer",level:3},{value:"<code>fix</code>",id:"fix",level:4},{value:"IncompatiblePhaseFixer",id:"incompatiblephasefixer",level:3},{value:"<code>fixDownstream</code>",id:"fixdownstream",level:4},{value:"<code>fixTransformerUpstreams</code>",id:"fixtransformerupstreams",level:4},{value:"PhaseExtender",id:"phaseextender",level:3},{value:"<code>extendDownstream</code>",id:"extenddownstream",level:4},{value:"<code>extendUpstream</code>",id:"extendupstream",level:4},{value:"PhaseIssues",id:"phaseissues",level:3},{value:"PhasePrecedence",id:"phaseprecedence",level:3},{value:"TransformerPhaseProcessor",id:"transformerphaseprocessor",level:3},{value:"<code>process</code>",id:"process",level:4},{value:"<code>inferUnknown</code>",id:"inferunknown",level:4},{value:"<code>processSwer</code>",id:"processswer",level:4},{value:"TransformerPhaseType",id:"transformerphasetype",level:3},{value:"XyPhaseProcessor",id:"xyphaseprocessor",level:3},{value:"<code>assignPrimaryPhases</code>",id:"assignprimaryphases",level:4}],g={toc:d},c="wrapper";function y(e){let{components:a}=e,t=(0,r.A)(e,i);return(0,s.yg)(c,(0,n.A)({},g,t,{components:a,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"The phase consistency module is used to repair phase inconsistencies in a ",(0,s.yg)("inlineCode",{parentName:"p"},"NetworkService"),"."),(0,s.yg)("h2",{id:"quick-start"},"Quick Start"),(0,s.yg)("p",null,"The simplest, and most common use of this module is via the ",(0,s.yg)("inlineCode",{parentName:"p"},"PhaseConsistencyProcessor")," class and the ",(0,s.yg)("inlineCode",{parentName:"p"},"makeConsistent")," function, which takes the following\nparameters:"),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"getTransformerPhaseType"),(0,s.yg)("td",{parentName:"tr",align:null},"Callback to get the ",(0,s.yg)("inlineCode",{parentName:"td"},"TransformerPhaseType")," for a transformer ID from the source data.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"getFileId"),(0,s.yg)("td",{parentName:"tr",align:null},"Callback to get the source file associated with an ID.")))),(0,s.yg)(o.A,{groupId:"code-example",defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},(0,s.yg)(l.A,{value:"kotlin",mdxType:"TabItem"},(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-kotlin"},'val logger = LoggerFactory.getLogger(javaClass);\nval issues = PhaseIssues(logger)\nval lvThreshold = 1000\n\nval phaseConsistencyProcessor = PhaseConsistencyProcessor(issues, lvThreshold)\n\nphaseConsistencyProcessor.makeConsistent(\n    networkService,\n    getTransformerPhaseType = { sourceId ->\n        mapToTransformerPhaseType(sourceData[sourceId]?.attributes?.getString("Phases"))\n    },\n    getFileId = { sourceId ->\n        sourceData[sourceId]?.fileId\n    }\n)\n\n')))),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"makeConsistent")," function will update the phases for the specified ",(0,s.yg)("inlineCode",{parentName:"p"},"networkService")," to ensure they are consistent, keeping as much of the source phase\ninformation as possible. To do this, the following processes will be run:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},"Set all service equipment with no known phases to single-phase."),(0,s.yg)("li",{parentName:"ol"},"Add a neutral to all LV switches within loops with multiple primary phases."),(0,s.yg)("li",{parentName:"ol"},"Set transformer phases from known 3-phase transformers."),(0,s.yg)("li",{parentName:"ol"},"Extend phases onto missing downstream."),(0,s.yg)("li",{parentName:"ol"},"Extend phases onto missing upstream."),(0,s.yg)("li",{parentName:"ol"},"Remove known non-3-phase from the network, keeping those phases as hints for later."),(0,s.yg)("li",{parentName:"ol"},"Set transformer phases from known single-phase and SWER transformers."),(0,s.yg)("li",{parentName:"ol"},"Repair the phases of any split 3-phase."),(0,s.yg)("li",{parentName:"ol"},"Extend phases onto missing downstream."),(0,s.yg)("li",{parentName:"ol"},"Infer transformer phases from unknown transformer phase types."),(0,s.yg)("li",{parentName:"ol"},"Extend phases onto missing downstream again to allow for transformer phases from step 8."),(0,s.yg)("li",{parentName:"ol"},"Extend phases onto missing upstream."),(0,s.yg)("li",{parentName:"ol"},"Replace invalid phases downstream."),(0,s.yg)("li",{parentName:"ol"},"Replace invalid phases upstream from transformers."),(0,s.yg)("li",{parentName:"ol"},"Replace invalid phases in loops."),(0,s.yg)("li",{parentName:"ol"},"Restore energy consumer phases."),(0,s.yg)("li",{parentName:"ol"},"Update XY phase codes to known phases using the hints where possible."),(0,s.yg)("li",{parentName:"ol"},"Replace invalid phases upstream from transformer again to allow for replaced XY from step 14."),(0,s.yg)("li",{parentName:"ol"},"Make all remaining network with missing phases 3-phase.")),(0,s.yg)("p",null,"In each instance where phases are spread, priority will be given to the phases emanating from transformers, then 3-phase over 2-phase over single-phase."),(0,s.yg)("admonition",{title:"Known Edge Case",type:"caution"},(0,s.yg)("p",{parentName:"admonition"},"There is a known edge case that is not supported by the above processing. If you have a section of 3-phase backbone with an incorrect SWER segment above a split\n3-phase regulator (each phase going through a separate transformer), the results of the consistency processing will be inaccurate/broken. In this case you will\nneed to either fix the SWER segment in the source system and generate a new extract, or update it manually in the extracted source data.")),(0,s.yg)("h2",{id:"repair-the-phases-of-any-split-3-phase"},"Repair the phases of any split 3-phase"),(0,s.yg)("p",null,"When a section of 3-phase backbone is split into three separate cables for an underground span in a source system that does not provide the actual phases of the\ncables (just the number of cores), you end up with all the cables being marked as phase ",(0,s.yg)("inlineCode",{parentName:"p"},"X"),". If you do not repair this, you will end up with each of the cables\nbeing given the same phase, which can break the feeder downstream in strange ways (far from the site of the error) due to conflicting information from the\ntransformers."),(0,s.yg)("p",null,"In order to fix this, we detect termination points where a 3-phase cable is split into three individual phase cables that later join back together, and replace\nthese ",(0,s.yg)("inlineCode",{parentName:"p"},"X")," phase cables with one each of ",(0,s.yg)("inlineCode",{parentName:"p"},"A"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"B")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"C"),'. Since some source systems do not need to be electrically correct (e.g. some GIS systems) we also\ndetect where a single span of single core cable is attached between the 3-phase and the split, which has been observed to make diagrams "prettier".'),(0,s.yg)("h2",{id:"sub-processors"},"Sub-processors"),(0,s.yg)("p",null,"The following sub-processors are used to make a ",(0,s.yg)("inlineCode",{parentName:"p"},"NetworkService")," consistent. Each of these can be used separately to perform their actions if desired."),(0,s.yg)("h3",{id:"lvswitchphaserepairer"},"LvSwitchPhaseRepairer"),(0,s.yg)("p",null,"Several of our migrators use CIM inputs with split-phase switches (allowing for un-ganged switching). When these switches are in LV, they often exclude a switch\non the neutral wire, which leads to our switch collapsing algorithms creating a switch without a neutral. If these switches are found in loops, it causes our\nphase consistency algorithms to remove the neutrals from surrounding network due to processing ",(0,s.yg)("inlineCode",{parentName:"p"},"ABC")," at a higher priority than ",(0,s.yg)("inlineCode",{parentName:"p"},"ABCN"),"."),(0,s.yg)("p",null,"This processor adds a neutral to all LV switches that have more than a singular phase within a loop. If these neutrals aren't required, they will be removed by\nexisting processors, otherwise they will prevent the removal of the neutral wire."),(0,s.yg)("h3",{id:"droppedphaseloopfixer"},"DroppedPhaseLoopFixer"),(0,s.yg)("p",null,"A class that can be used to fix the phasing of loops that contain segments surrounded by segments with fewer phases, resulting in dropped phases."),(0,s.yg)("h4",{id:"fix"},(0,s.yg)("inlineCode",{parentName:"h4"},"fix")),(0,s.yg)("p",null,"Fix 3-phase loop segments that are surrounded by single-phase segments. If there is a 3-phase transformer in the loop, or there\nis another 3-phase segment in the loop (including the incoming connection to the loop), create a 3-phase path between them, otherwise, remove the island\n3-phase segment and any downstream 3-phase."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))),(0,s.yg)("h3",{id:"incompatiblephasefixer"},"IncompatiblePhaseFixer"),(0,s.yg)("p",null,"A class for fixing incompatible phase combinations."),(0,s.yg)("h4",{id:"fixdownstream"},(0,s.yg)("inlineCode",{parentName:"h4"},"fixDownstream")),(0,s.yg)("p",null,"Fix any phase incompatibilities in a downstream direction. This will replace the incompatible downstream phases with the valid upstream phases.\nIncompatible phases are any phases that are not a subset of the upstream phases, or an unknown representation of those phases. To do this,\nphases will be spread in the following order:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},"From any transformer not in a loop."),(0,s.yg)("li",{parentName:"ol"},"From the low voltage side of any transformer in a loop."),(0,s.yg)("li",{parentName:"ol"},"From any non-transformer not in a loop."),(0,s.yg)("li",{parentName:"ol"},"From any non-transformer in a loop.")),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))),(0,s.yg)("h4",{id:"fixtransformerupstreams"},(0,s.yg)("inlineCode",{parentName:"h4"},"fixTransformerUpstreams")),(0,s.yg)("p",null,"Fix any paths to transformers that have phase incompatibilities in an upstream direction. This will replace the incompatible upstream phases with the\nvalid transformer phases. Incompatible phases are any phases that are not a superset of the transformer phases, or an unknown representation of those\nphases."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))),(0,s.yg)("h3",{id:"phaseextender"},"PhaseExtender"),(0,s.yg)("p",null,"A class for extending known phases onto terminals with missing phases. This is done in a downstream direction first, giving priority to known transformer\nphases, then 3-phase over single-phase."),(0,s.yg)("h4",{id:"extenddownstream"},(0,s.yg)("inlineCode",{parentName:"h4"},"extendDownstream")),(0,s.yg)("p",null,"Extend phases downstream onto terminals with missing phases for the specified ",(0,s.yg)("inlineCode",{parentName:"p"},"networkService"),". Priority will be given to transformer phases, then following\nthe order defined by ",(0,s.yg)("inlineCode",{parentName:"p"},"PhasePrecedence.PRECEDENCE"),"."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))),(0,s.yg)("h4",{id:"extendupstream"},(0,s.yg)("inlineCode",{parentName:"h4"},"extendUpstream")),(0,s.yg)("p",null,"Extend known phases upstream onto terminals with unknown phases for the specified ",(0,s.yg)("inlineCode",{parentName:"p"},"networkService"),". Priority will be given to transformer phases, then\nfollowing the order defined by ",(0,s.yg)("inlineCode",{parentName:"p"},"PhasePrecedence.PRECEDENCE"),"."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))),(0,s.yg)("h3",{id:"phaseissues"},"PhaseIssues"),(0,s.yg)("p",null,"A collection of issue trackers for tracking problems corrected by the phase consistency processing."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Tracker"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"inconsistentPhases"),(0,s.yg)("td",{parentName:"tr",align:null},"Tracks items where the phases in the EWB database do not match the phases in the source data.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"txMultipleUpstreamFeeds"),(0,s.yg)("td",{parentName:"tr",align:null},"Tracks transformers where phase consistency could not be processed due to having multiple paths to a feeder head, so direction could not be determines.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"txWithConflictingSwer"),(0,s.yg)("td",{parentName:"tr",align:null},"Tracks transformers with conflicts between SWER phases and voltages.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"txWithMissingSourcePhases"),(0,s.yg)("td",{parentName:"tr",align:null},"Tracks transformers where there was no phase information available in the source data, and the phases had to be inferred.")))),(0,s.yg)("h3",{id:"phaseprecedence"},"PhasePrecedence"),(0,s.yg)("p",null,"Defines the order of precedence that phases will be processed, and which phases belong to each category."),(0,s.yg)("h3",{id:"transformerphaseprocessor"},"TransformerPhaseProcessor"),(0,s.yg)("p",null,"A class for processing ",(0,s.yg)("inlineCode",{parentName:"p"},"PowerTransformer")," phases."),(0,s.yg)("h4",{id:"process"},(0,s.yg)("inlineCode",{parentName:"h4"},"process")),(0,s.yg)("p",null,"Validate that ",(0,s.yg)("inlineCode",{parentName:"p"},"PowerTransformer")," phases make sense, and update them if they don't. Transformers with unknown source phases (or SWER without SWER voltage)\nwill be stored for later processing via ",(0,s.yg)("inlineCode",{parentName:"p"},"inferUnknown"),"."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"getTransformerType"),(0,s.yg)("td",{parentName:"tr",align:null},"A callback to get the ",(0,s.yg)("inlineCode",{parentName:"td"},"TransformerPhaseType")," for the specified ID. Returning ",(0,s.yg)("inlineCode",{parentName:"td"},"null")," will be treated the same as ",(0,s.yg)("inlineCode",{parentName:"td"},"TransformerPhaseType.UNKNOWN"),".")))),(0,s.yg)("h4",{id:"inferunknown"},(0,s.yg)("inlineCode",{parentName:"h4"},"inferUnknown")),(0,s.yg)("p",null,"Validate that the phases of ",(0,s.yg)("inlineCode",{parentName:"p"},"powerTransformer")," with unknown type make sense, and update them if they don't."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"powerTransformer"),(0,s.yg)("td",{parentName:"tr",align:null},"The ",(0,s.yg)("inlineCode",{parentName:"td"},"PowerTransformer")," to process.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"up"),(0,s.yg)("td",{parentName:"tr",align:null},"The upstream terminal of ",(0,s.yg)("inlineCode",{parentName:"td"},"powerTransformer"),".")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"down"),(0,s.yg)("td",{parentName:"tr",align:null},"The downstream terminals of ",(0,s.yg)("inlineCode",{parentName:"td"},"powerTransformer"),".")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"onTypeDetermined"),(0,s.yg)("td",{parentName:"tr",align:null},"Consumer that is used to perform processing (e.g. logging) when the type of the ",(0,s.yg)("inlineCode",{parentName:"td"},"powerTransformer")," is determined.")))),(0,s.yg)("p",null,"Returns a list of terminals that have been updated."),(0,s.yg)("h4",{id:"processswer"},(0,s.yg)("inlineCode",{parentName:"h4"},"processSwer")),(0,s.yg)("p",null,"Validate that the phases of SWER ",(0,s.yg)("inlineCode",{parentName:"p"},"powerTransformer")," make sense, and update them if they don't."),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"powerTransformer"),(0,s.yg)("td",{parentName:"tr",align:null},"The ",(0,s.yg)("inlineCode",{parentName:"td"},"PowerTransformer")," to process.")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"up"),(0,s.yg)("td",{parentName:"tr",align:null},"The upstream terminal of ",(0,s.yg)("inlineCode",{parentName:"td"},"powerTransformer"),".")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"down"),(0,s.yg)("td",{parentName:"tr",align:null},"The downstream terminals of ",(0,s.yg)("inlineCode",{parentName:"td"},"powerTransformer"),".")))),(0,s.yg)("p",null,"Return a list of terminals that have been updated."),(0,s.yg)("h3",{id:"transformerphasetype"},"TransformerPhaseType"),(0,s.yg)("p",null,"An enumeration of the phase type for a ",(0,s.yg)("inlineCode",{parentName:"p"},"PowerTransformer"),"."),(0,s.yg)("h3",{id:"xyphaseprocessor"},"XyPhaseProcessor"),(0,s.yg)("p",null,"A class that can be used to replace XY phases with primary phases. Takes an optional phase allocation algorithm used to determine which candidate phase to use\nwhen an exact match could not be found. Takes two parameters, the terminal being processed and the candidate phases."),(0,s.yg)("admonition",{title:"Ignoring Candidates",type:"caution"},(0,s.yg)("p",{parentName:"admonition"},"There is no validation of the returned phase code. If you return a phase that is not in the candidates, you will introduce a phase inconsistency.")),(0,s.yg)("p",null,"The default phase allocation algorithm chooses a random candidate based on the hash of the terminals conducting equipments mRID. This does a reasonable job of\nspreading the phases while also being repeatable, giving stability to re-runs of an extract."),(0,s.yg)("admonition",{title:"Precondition",type:"info"},(0,s.yg)("p",{parentName:"admonition"},"All terminals in the network service that are connected to XY spans must have phases assigned prior to calling this function for it to work correctly.\nThe ",(0,s.yg)("inlineCode",{parentName:"p"},"PhaseExtender")," class can be used to ensure this precondition is met.")),(0,s.yg)("h4",{id:"assignprimaryphases"},(0,s.yg)("inlineCode",{parentName:"h4"},"assignPrimaryPhases")),(0,s.yg)("p",null,"Assign primary phases to all XY terminals. This is done with the following priority:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("p",{parentName:"li"},"Continue any matching known phasing:"),(0,s.yg)("p",{parentName:"li"},"This will continue AB, BC or AC over XY, or A, B or C over X, maintaining neutrals.")),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("p",{parentName:"li"},"Back-fill from any subsets of known phases."),(0,s.yg)("p",{parentName:"li"},"This will back-fill AB or AC over XY is there is a downstream A, BC or AB from B and AC or BC from C, maintaining neutrals. Which phase is used\nis determined by the phase allocation algorithm.")),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("p",{parentName:"li"},"Allocate a valid subset phase using the phase allocation algorithm."),(0,s.yg)("p",{parentName:"li"},"This will allocate one of the following:"),(0,s.yg)("ul",{parentName:"li"},(0,s.yg)("li",{parentName:"ul"},"AB, BC or AC for an XY below ABC"),(0,s.yg)("li",{parentName:"ul"},"A, B or C for an X below ABC"),(0,s.yg)("li",{parentName:"ul"},"A or B for an X below AB"),(0,s.yg)("li",{parentName:"ul"},"B or C for an X below BC"),(0,s.yg)("li",{parentName:"ul"},"C or A for an X below AC")))),(0,s.yg)("admonition",{title:"Transformer Phases",type:"note"},(0,s.yg)("p",{parentName:"admonition"},"While applying these rules, any transformers will be processed with the following translations where necessary:"),(0,s.yg)("ul",{parentName:"admonition"},(0,s.yg)("li",{parentName:"ul"},"HV to LV:",(0,s.yg)("ul",{parentName:"li"},(0,s.yg)("li",{parentName:"ul"},"ABC <-> ABCN"),(0,s.yg)("li",{parentName:"ul"},"AB <-> AN"),(0,s.yg)("li",{parentName:"ul"},"BC <-> BN"),(0,s.yg)("li",{parentName:"ul"},"AC <-> CN"))),(0,s.yg)("li",{parentName:"ul"},"HV to SWER:",(0,s.yg)("ul",{parentName:"li"},(0,s.yg)("li",{parentName:"ul"},"AB <-> A"),(0,s.yg)("li",{parentName:"ul"},"BC <-> B"),(0,s.yg)("li",{parentName:"ul"},"AC <-> C"))),(0,s.yg)("li",{parentName:"ul"},"SWER to LV",(0,s.yg)("ul",{parentName:"li"},(0,s.yg)("li",{parentName:"ul"},"A <-> AN"),(0,s.yg)("li",{parentName:"ul"},"B <-> BN"),(0,s.yg)("li",{parentName:"ul"},"C <-> CN"))))),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,s.yg)("th",{parentName:"tr",align:null},"Purpose"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"networkService"),(0,s.yg)("td",{parentName:"tr",align:null},"The network service to process.")))))}y.isMDXComponent=!0},5680:(e,a,t)=>{t.d(a,{xA:()=>h,yg:()=>g});var n=t(6540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach(function(a){r(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),p=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},h=function(e){var a=p(e.components);return n.createElement(i.Provider,{value:a},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef(function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),m=p(t),d=r,g=m["".concat(i,".").concat(d)]||m[d]||u[d]||s;return t?n.createElement(g,o(o({ref:a},h),{},{components:t})):n.createElement(g,o({ref:a},h))});function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=d;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<s;p++)o[p]=t[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9365:(e,a,t)=>{t.d(a,{A:()=>o});var n=t(6540),r=t(53);const s={tabItem:"tabItem_Ymn6"};function o(e){let{children:a,hidden:t,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,o),hidden:t},a)}}}]);