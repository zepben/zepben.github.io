(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{101:function(e,a,t){"use strict";function n(e){var a,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(a=0;a<e.length;a++)e[a]&&(t=n(e[a]))&&(r&&(r+=" "),r+=t);else for(a in e)e[a]&&(r&&(r+=" "),r+=a);return r}a.a=function(){for(var e,a,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(a=n(e))&&(r&&(r+=" "),r+=a);return r}},102:function(e,a,t){"use strict";t.d(a,"a",(function(){return h}));var n=t(0),r=t.n(n);function s(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){s(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),p=function(e){var a=r.a.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):i({},a,{},e)),t},b={inlineCode:"code",wrapper:function(e){var a=e.children;return r.a.createElement(r.a.Fragment,{},a)}},m=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(t),h=n,d=m["".concat(o,".").concat(h)]||m[h]||b[h]||s;return t?r.a.createElement(d,i({ref:a},c,{components:t})):r.a.createElement(d,i({ref:a},c))}));function h(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var s=t.length,o=new Array(s);o[0]=m;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var c=2;c<s;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},104:function(e,a,t){"use strict";var n=t(0),r=t(105);a.a=function(){var e=Object(n.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},105:function(e,a,t){"use strict";var n=t(0),r=Object(n.createContext)(void 0);a.a=r},106:function(e,a,t){"use strict";var n=t(0),r=t.n(n),s=t(104),o=t(101),i=t(55),l=t.n(i),c=37,p=39;a.a=function(e){var a=e.lazy,t=e.block,i=e.defaultValue,b=e.values,m=e.groupId,h=e.className,d=Object(s.a)(),u=d.tabGroupChoices,O=d.setTabGroupChoices,j=Object(n.useState)(i),f=j[0],N=j[1],g=n.Children.toArray(e.children);if(null!=m){var w=u[m];null!=w&&w!==f&&b.some((function(e){return e.value===w}))&&N(w)}var v=function(e){N(e),null!=m&&O(m,e)},y=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":t},h)},b.map((function(e){var a=e.value,t=e.label;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":f===a,className:Object(o.a)("tabs__item",l.a.tabItem,{"tabs__item--active":f===a}),key:a,ref:function(e){return y.push(e)},onKeyDown:function(e){!function(e,a,t){switch(t.keyCode){case p:!function(e,a){var t=e.indexOf(a)+1;e[t]?e[t].focus():e[0].focus()}(e,a);break;case c:!function(e,a){var t=e.indexOf(a)-1;e[t]?e[t].focus():e[e.length-1].focus()}(e,a)}}(y,e.target,e)},onFocus:function(){return v(a)},onClick:function(){v(a)}},t)}))),a?Object(n.cloneElement)(g.filter((function(e){return e.props.value===f}))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},g.map((function(e,a){return Object(n.cloneElement)(e,{key:a,hidden:e.props.value!==f})}))))}},107:function(e,a,t){"use strict";var n=t(3),r=t(0),s=t.n(r);a.a=function(e){var a=e.children,t=e.hidden,r=e.className;return s.a.createElement("div",Object(n.a)({role:"tabpanel"},{hidden:t,className:r}),a)}},97:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"metadata",(function(){return c})),t.d(a,"toc",(function(){return p})),t.d(a,"default",(function(){return m}));var n=t(3),r=t(7),s=(t(0),t(102)),o=t(106),i=t(107),l={id:"phase-consistency",title:"Phase Consistency Processor"},c={unversionedId:"phase-consistency",id:"version-0.10.0/phase-consistency",isDocsHomePage:!1,title:"Phase Consistency Processor",description:"The phase consistency module is used to repair phase inconsistencies in a NetworkService.",source:"@site/versioned_docs/version-0.10.0/phase-consistency.mdx",slug:"/phase-consistency",permalink:"/evolve/docs/migrator-sdk-jvm/0.10.0/phase-consistency",version:"0.10.0",sidebar:"version-0.10.0/someSidebar",previous:{title:"Migrator SDK Overview",permalink:"/evolve/docs/migrator-sdk-jvm/0.10.0/"}},p=[{value:"Quick Start",id:"quick-start",children:[]},{value:"Repair the phases of any split 3-phase",id:"repair-the-phases-of-any-split-3-phase",children:[]},{value:"Sub-processors",id:"sub-processors",children:[{value:"DroppedPhaseLoopFixer",id:"droppedphaseloopfixer",children:[]},{value:"IncompatiblePhaseFixer",id:"incompatiblephasefixer",children:[]},{value:"PhaseExtender",id:"phaseextender",children:[]},{value:"PhaseIssues",id:"phaseissues",children:[]},{value:"PhasePrecedence",id:"phaseprecedence",children:[]},{value:"TransformerPhaseProcessor",id:"transformerphaseprocessor",children:[]},{value:"TransformerPhaseType",id:"transformerphasetype",children:[]},{value:"XyPhaseProcessor",id:"xyphaseprocessor",children:[]}]}],b={toc:p};function m(e){var a=e.components,t=Object(r.a)(e,["components"]);return Object(s.a)("wrapper",Object(n.a)({},b,t,{components:a,mdxType:"MDXLayout"}),Object(s.a)("p",null,"The phase consistency module is used to repair phase inconsistencies in a ",Object(s.a)("inlineCode",{parentName:"p"},"NetworkService"),"."),Object(s.a)("h2",{id:"quick-start"},"Quick Start"),Object(s.a)("p",null,"The simplest, and most common use of this module is via the ",Object(s.a)("inlineCode",{parentName:"p"},"PhaseConsistencyProcessor")," class and the ",Object(s.a)("inlineCode",{parentName:"p"},"makeConsistent")," function, which takes the following\nparameters:"),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"getTransformerPhaseType"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Callback to get the ",Object(s.a)("inlineCode",{parentName:"td"},"TransformerPhaseType")," for a transformer ID from the source data.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"getFileId"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Callback to get the source file associated with an ID.")))),Object(s.a)(o.a,{groupId:"code-example",defaultValue:"java",values:[{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},Object(s.a)(i.a,{value:"kotlin",mdxType:"TabItem"},Object(s.a)("pre",null,Object(s.a)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'val logger = LoggerFactory.getLogger(javaClass);\nval issues = PhaseIssues(logger)\nval lvThreshold = 1000\n\nval phaseConsistencyProcessor = PhaseConsistencyProcessor(issues, lvThreshold)\n\nphaseConsistencyProcessor.makeConsistent(\n    networkService,\n    getTransformerPhaseType = { sourceId ->\n        mapToTransformerPhaseType(sourceData[sourceId]?.attributes?.getString("Phases"))\n    },\n    getFileId = { sourceId ->\n        sourceData[sourceId]?.fileId\n    }\n)\n\n')))),Object(s.a)("p",null,"The ",Object(s.a)("inlineCode",{parentName:"p"},"makeConsistent")," function will update the phases for the specified ",Object(s.a)("inlineCode",{parentName:"p"},"networkService")," to ensure they are consistent, keeping as much of the source phase\ninformation as possible. To do this, the following processes will be run:"),Object(s.a)("ol",null,Object(s.a)("li",{parentName:"ol"},"Set transformer phases from known transformer phase types using a ",Object(s.a)("inlineCode",{parentName:"li"},"TransformerPhaseProcessor"),"."),Object(s.a)("li",{parentName:"ol"},"Repair the phases of any split 3-phase."),Object(s.a)("li",{parentName:"ol"},"Extend phases onto missing downstream using a ",Object(s.a)("inlineCode",{parentName:"li"},"PhaseExtender"),"."),Object(s.a)("li",{parentName:"ol"},"Infer transformer phases from unknown transformer phase type using a ",Object(s.a)("inlineCode",{parentName:"li"},"TransformerPhaseProcessor"),"."),Object(s.a)("li",{parentName:"ol"},"Extend phases onto missing downstream again to allow for transformer phases from step 4 using a ",Object(s.a)("inlineCode",{parentName:"li"},"PhaseExtender"),"."),Object(s.a)("li",{parentName:"ol"},"Extend phases onto missing upstream using a ",Object(s.a)("inlineCode",{parentName:"li"},"PhaseExtender"),"."),Object(s.a)("li",{parentName:"ol"},"Replace invalid phases downstream using an ",Object(s.a)("inlineCode",{parentName:"li"},"IncompatiblePhaseFixer"),"."),Object(s.a)("li",{parentName:"ol"},"Replace invalid phases upstream from transformers using an ",Object(s.a)("inlineCode",{parentName:"li"},"IncompatiblePhaseFixer"),"."),Object(s.a)("li",{parentName:"ol"},"Replace invalid phases in loops using a ",Object(s.a)("inlineCode",{parentName:"li"},"DroppedPhaseLoopFixer"),"."),Object(s.a)("li",{parentName:"ol"},"Update XY phase codes to known phases using an ",Object(s.a)("inlineCode",{parentName:"li"},"XyPhaseProcessor"),"."),Object(s.a)("li",{parentName:"ol"},"Replace invalid phases upstream from transformers using an ",Object(s.a)("inlineCode",{parentName:"li"},"IncompatiblePhaseFixer")," again after the XY processing in step 10."),Object(s.a)("li",{parentName:"ol"},"Make all remaining network with missing phases 3-phase.")),Object(s.a)("p",null,"In each instance where phases are spread, priority will be given to the phases emanating from transformers, then 3-phase over 2-phase over single-phase."),Object(s.a)("div",{className:"admonition admonition-caution alert alert--warning"},Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.a)("h5",{parentName:"div"},Object(s.a)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.a)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(s.a)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"Known Edge Case")),Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(s.a)("p",{parentName:"div"},"There is a known edge case that is not supported by the above processing. If you have a section of 3-phase backbone with an incorrect SWER segment above a split\n3-phase regulator (each phase going through a separate transformer), the results of the consistency processing will be inaccurate/broken. In this case you will\nneed to either fix the SWER segment in the source system and generate a new extract, or update it manually in the extracted source data."))),Object(s.a)("h2",{id:"repair-the-phases-of-any-split-3-phase"},"Repair the phases of any split 3-phase"),Object(s.a)("p",null,"When a section of 3-phase backbone is split into three separate cables for an underground span in a source system that does not provide the actual phases of the\ncables (just the number of cores), you end up with all the cables being marked as phase ",Object(s.a)("inlineCode",{parentName:"p"},"X"),". If you do not repair this, you will end up with each of the cables\nbeing given the same phase, which can break the feeder downstream in strange ways (far from the site of the error) due to conflicting information from the\ntransformers."),Object(s.a)("p",null,"In order to fix this, we detect termination points where a 3-phase cable is split into three individual phase cables that later join back together, and replace\nthese ",Object(s.a)("inlineCode",{parentName:"p"},"X")," phase cables with one each of ",Object(s.a)("inlineCode",{parentName:"p"},"A"),", ",Object(s.a)("inlineCode",{parentName:"p"},"B")," and ",Object(s.a)("inlineCode",{parentName:"p"},"C"),'. Since some source systems do not need to be electrically correct (e.g. some GIS systems) we also\ndetect where a single span of single core cable is attached between the 3-phase and the split, which has been observed to make diagrams "prettier".'),Object(s.a)("h2",{id:"sub-processors"},"Sub-processors"),Object(s.a)("p",null,"The following sub-processors are used to make a ",Object(s.a)("inlineCode",{parentName:"p"},"NetworkService")," consistent. Each of these can be used separately to perform their actions if desired."),Object(s.a)("h3",{id:"droppedphaseloopfixer"},"DroppedPhaseLoopFixer"),Object(s.a)("p",null,"A class that can be used to fix the phasing of loops that contain segments surrounded by segments with fewer phases, resulting in dropped phases."),Object(s.a)("h4",{id:"fix"},Object(s.a)("inlineCode",{parentName:"h4"},"fix")),Object(s.a)("p",null,"Fix 3-phase loop segments that are surrounded by single-phase segments. If there is a 3-phase transformer in the loop, or there\nis another 3-phase segment in the loop (including the incoming connection to the loop), create a 3-phase path between them, otherwise, remove the island\n3-phase segment and any downstream 3-phase."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))),Object(s.a)("h3",{id:"incompatiblephasefixer"},"IncompatiblePhaseFixer"),Object(s.a)("p",null,"A class for fixing incompatible phase combinations."),Object(s.a)("h4",{id:"fixdownstream"},Object(s.a)("inlineCode",{parentName:"h4"},"fixDownstream")),Object(s.a)("p",null,"Fix any phase incompatibilities in a downstream direction. This will replace the incompatible downstream phases with the valid upstream phases.\nIncompatible phases are any phases that are not a subset of the upstream phases, or an unknown representation of those phases. To do this,\nphases will be spread in the following order:"),Object(s.a)("ol",null,Object(s.a)("li",{parentName:"ol"},"From any transformer not in a loop."),Object(s.a)("li",{parentName:"ol"},"From the low voltage side of any transformer in a loop."),Object(s.a)("li",{parentName:"ol"},"From any non-transformer not in a loop."),Object(s.a)("li",{parentName:"ol"},"From any non-transformer in a loop.")),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))),Object(s.a)("h4",{id:"fixtransformerupstreams"},Object(s.a)("inlineCode",{parentName:"h4"},"fixTransformerUpstreams")),Object(s.a)("p",null,"Fix any paths to transformers that have phase incompatibilities in an upstream direction. This will replace the incompatible upstream phases with the\nvalid transformer phases. Incompatible phases are any phases that are not a superset of the transformer phases, or an unknown representation of those\nphases."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))),Object(s.a)("h3",{id:"phaseextender"},"PhaseExtender"),Object(s.a)("p",null,"A class for extending known phases onto terminals with missing phases. This is done in a downstream direction first, giving priority to known transformer\nphases, then 3-phase over single-phase."),Object(s.a)("h4",{id:"extenddownstream"},Object(s.a)("inlineCode",{parentName:"h4"},"extendDownstream")),Object(s.a)("p",null,"Extend phases downstream onto terminals with missing phases for the specified ",Object(s.a)("inlineCode",{parentName:"p"},"networkService"),". Priority will be given to transformer phases, then following\nthe order defined by ",Object(s.a)("inlineCode",{parentName:"p"},"PhasePrecedence.PRECEDENCE"),"."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))),Object(s.a)("h4",{id:"extendupstream"},Object(s.a)("inlineCode",{parentName:"h4"},"extendUpstream")),Object(s.a)("p",null,"Extend known phases upstream onto terminals with unknown phases for the specified ",Object(s.a)("inlineCode",{parentName:"p"},"networkService"),". Priority will be given to transformer phases, then\nfollowing the order defined by ",Object(s.a)("inlineCode",{parentName:"p"},"PhasePrecedence.PRECEDENCE"),"."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))),Object(s.a)("h3",{id:"phaseissues"},"PhaseIssues"),Object(s.a)("p",null,"A collection of issue trackers for tracking problems corrected by the phase consistency processing."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Tracker"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"inconsistentPhases"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tracks items where the phases in the EWB database do not match the phases in the source data.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"txMultipleUpstreamFeeds"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tracks transformers where phase consistency could not be processed due to having multiple paths to a feeder head, so direction could not be determines.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"txWithConflictingSwer"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tracks transformers with conflicts between SWER phases and voltages.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"txWithMissingSourcePhases"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tracks transformers where there was no phase information available in the source data, and the phases had to be inferred.")))),Object(s.a)("h3",{id:"phaseprecedence"},"PhasePrecedence"),Object(s.a)("p",null,"Defines the order of precedence that phases will be processed, and which phases belong to each category."),Object(s.a)("h3",{id:"transformerphaseprocessor"},"TransformerPhaseProcessor"),Object(s.a)("p",null,"A class for processing ",Object(s.a)("inlineCode",{parentName:"p"},"PowerTransformer")," phases."),Object(s.a)("h4",{id:"process"},Object(s.a)("inlineCode",{parentName:"h4"},"process")),Object(s.a)("p",null,"Validate that ",Object(s.a)("inlineCode",{parentName:"p"},"PowerTransformer")," phases make sense, and update them if they don't. Transformers with unknown source phases (or SWER without SWER voltage)\nwill be stored for later processing via ",Object(s.a)("inlineCode",{parentName:"p"},"inferUnknown"),"."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"getTransformerType"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"A callback to get the ",Object(s.a)("inlineCode",{parentName:"td"},"TransformerPhaseType")," for the specified ID. Returning ",Object(s.a)("inlineCode",{parentName:"td"},"null")," will be treated the same as ",Object(s.a)("inlineCode",{parentName:"td"},"TransformerPhaseType.UNKNOWN"),".")))),Object(s.a)("h4",{id:"inferunknown"},Object(s.a)("inlineCode",{parentName:"h4"},"inferUnknown")),Object(s.a)("p",null,"Validate that the phases of ",Object(s.a)("inlineCode",{parentName:"p"},"powerTransformer")," with unknown type make sense, and update them if they don't."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"powerTransformer"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The ",Object(s.a)("inlineCode",{parentName:"td"},"PowerTransformer")," to process.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"up"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The upstream terminal of ",Object(s.a)("inlineCode",{parentName:"td"},"powerTransformer"),".")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"down"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The downstream terminals of ",Object(s.a)("inlineCode",{parentName:"td"},"powerTransformer"),".")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"onTypeDetermined"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"Consumer that is used to perform processing (e.g. logging) when the type of the ",Object(s.a)("inlineCode",{parentName:"td"},"powerTransformer")," is determined.")))),Object(s.a)("p",null,"Returns a list of terminals that have been updated."),Object(s.a)("h4",{id:"processswer"},Object(s.a)("inlineCode",{parentName:"h4"},"processSwer")),Object(s.a)("p",null,"Validate that the phases of SWER ",Object(s.a)("inlineCode",{parentName:"p"},"powerTransformer")," make sense, and update them if they don't."),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"powerTransformer"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The ",Object(s.a)("inlineCode",{parentName:"td"},"PowerTransformer")," to process.")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"up"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The upstream terminal of ",Object(s.a)("inlineCode",{parentName:"td"},"powerTransformer"),".")),Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"down"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The downstream terminals of ",Object(s.a)("inlineCode",{parentName:"td"},"powerTransformer"),".")))),Object(s.a)("p",null,"Return a list of terminals that have been updated."),Object(s.a)("h3",{id:"transformerphasetype"},"TransformerPhaseType"),Object(s.a)("p",null,"An enumeration of the phase type for a ",Object(s.a)("inlineCode",{parentName:"p"},"PowerTransformer"),"."),Object(s.a)("h3",{id:"xyphaseprocessor"},"XyPhaseProcessor"),Object(s.a)("p",null,"A class that can be used to replace XY phases with primary phases. Takes an optional phase allocation algorithm used to determine which candidate phase to use\nwhen an exact match could not be found. Takes two parameters, the terminal being processed and the candidate phases."),Object(s.a)("div",{className:"admonition admonition-caution alert alert--warning"},Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.a)("h5",{parentName:"div"},Object(s.a)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.a)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(s.a)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"Ignoring Candidates")),Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(s.a)("p",{parentName:"div"},"There is no validation of the returned phase code. If you return a phase that is not in the candidates, you will introduce a phase inconsistency."))),Object(s.a)("p",null,"The default phase allocation algorithm chooses a random candidate based on the hash of the terminals conducting equipments mRID. This does a reasonable job of\nspreading the phases while also being repeatable, giving stability to re-runs of an extract."),Object(s.a)("div",{className:"admonition admonition-info alert alert--info"},Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.a)("h5",{parentName:"div"},Object(s.a)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.a)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.a)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"Precondition")),Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(s.a)("p",{parentName:"div"},"All terminals in the network service that are connected to XY spans must have phases assigned prior to calling this function for it to work correctly.\nThe ",Object(s.a)("inlineCode",{parentName:"p"},"PhaseExtender")," class can be used to ensure this precondition is met."))),Object(s.a)("h4",{id:"assignprimaryphases"},Object(s.a)("inlineCode",{parentName:"h4"},"assignPrimaryPhases")),Object(s.a)("p",null,"Assign primary phases to all XY terminals. This is done with the following priority:"),Object(s.a)("ol",null,Object(s.a)("li",{parentName:"ol"},Object(s.a)("p",{parentName:"li"},"Continue any matching known phasing:"),Object(s.a)("p",{parentName:"li"},"This will continue AB, BC or AC over XY, or A, B or C over X, maintaining neutrals.")),Object(s.a)("li",{parentName:"ol"},Object(s.a)("p",{parentName:"li"},"Back-fill from any subsets of known phases."),Object(s.a)("p",{parentName:"li"},"This will back-fill AB or AC over XY is there is a downstream A, BC or AB from B and AC or BC from C, maintaining neutrals. Which phase is used\nis determined by the phase allocation algorithm.")),Object(s.a)("li",{parentName:"ol"},Object(s.a)("p",{parentName:"li"},"Allocate a valid subset phase using the phase allocation algorithm."),Object(s.a)("p",{parentName:"li"},"This will allocate one of the following:"),Object(s.a)("ul",{parentName:"li"},Object(s.a)("li",{parentName:"ul"},"AB, BC or AC for an XY below ABC"),Object(s.a)("li",{parentName:"ul"},"A, B or C for an X below ABC"),Object(s.a)("li",{parentName:"ul"},"A or B for an X below AB"),Object(s.a)("li",{parentName:"ul"},"B or C for an X below BC"),Object(s.a)("li",{parentName:"ul"},"C or A for an X below AC")))),Object(s.a)("div",{className:"admonition admonition-note alert alert--secondary"},Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.a)("h5",{parentName:"div"},Object(s.a)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.a)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.a)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"Transformer Phases")),Object(s.a)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(s.a)("p",{parentName:"div"},"While applying these rules, any transformers will be processed with the following translations where necessary:"),Object(s.a)("ul",{parentName:"div"},Object(s.a)("li",{parentName:"ul"},"HV to LV:",Object(s.a)("ul",{parentName:"li"},Object(s.a)("li",{parentName:"ul"},"ABC <-> ABCN"),Object(s.a)("li",{parentName:"ul"},"AB <-> AN"),Object(s.a)("li",{parentName:"ul"},"BC <-> BN"),Object(s.a)("li",{parentName:"ul"},"AC <-> CN"))),Object(s.a)("li",{parentName:"ul"},"HV to SWER:",Object(s.a)("ul",{parentName:"li"},Object(s.a)("li",{parentName:"ul"},"AB <-> A"),Object(s.a)("li",{parentName:"ul"},"BC <-> B"),Object(s.a)("li",{parentName:"ul"},"AC <-> C"))),Object(s.a)("li",{parentName:"ul"},"SWER to LV",Object(s.a)("ul",{parentName:"li"},Object(s.a)("li",{parentName:"ul"},"A <-> AN"),Object(s.a)("li",{parentName:"ul"},"B <-> BN"),Object(s.a)("li",{parentName:"ul"},"C <-> CN")))))),Object(s.a)("table",null,Object(s.a)("thead",{parentName:"table"},Object(s.a)("tr",{parentName:"thead"},Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Parameter"),Object(s.a)("th",Object(n.a)({parentName:"tr"},{align:null}),"Purpose"))),Object(s.a)("tbody",{parentName:"table"},Object(s.a)("tr",{parentName:"tbody"},Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"networkService"),Object(s.a)("td",Object(n.a)({parentName:"tr"},{align:null}),"The network service to process.")))))}m.isMDXComponent=!0}}]);