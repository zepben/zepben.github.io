"use strict";(self.webpackChunkewb_sdk_python=self.webpackChunkewb_sdk_python||[]).push([["8600"],{52314:function(e,t,r){r.r(t),r.d(t,{frontMatter:()=>o,toc:()=>l,default:()=>h,metadata:()=>n,assets:()=>c,contentTitle:()=>a});var n=JSON.parse('{"id":"query-network-state-service","title":"Query Network State Service","description":"An implementation of the QueryNetworkStateService will provide an object-oriented wrapper for the gRPC library, with the ability to retrieve information about","source":"@site/versioned_docs/version-1.0.0/query-network-state-service.mdx","sourceDirName":".","slug":"/query-network-state-service","permalink":"/evolve/docs/ewb-sdk-python/1.0.0/query-network-state-service","draft":false,"unlisted":false,"tags":[],"version":"1.0.0","frontMatter":{"id":"query-network-state-service","title":"Query Network State Service"},"sidebar":"someSidebar","previous":{"title":"Query Network State Client","permalink":"/evolve/docs/ewb-sdk-python/1.0.0/query-network-state-client"},"next":{"title":"Update Network State Client","permalink":"/evolve/docs/ewb-sdk-python/1.0.0/update-network-state-client"}}'),s=r(74848),i=r(84429);r(33021),r(72207);let o={id:"query-network-state-service",title:"Query Network State Service"},a,c={},l=[{value:"Creating callbacks",id:"creating-callbacks",level:2},{value:"on_get_current_states",id:"on_get_current_states",level:3},{value:"onCurrentStatesStatus",id:"oncurrentstatesstatus",level:3},{value:"onProcessingError",id:"onprocessingerror",level:3},{value:"Registering callbacks",id:"registering-callbacks",level:2},{value:"Registering the service",id:"registering-the-service",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function d(e){let t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["An implementation of the ",(0,s.jsx)(t.code,{children:"QueryNetworkStateService"})," will provide an object-oriented wrapper for the gRPC library, with the ability to retrieve information about\nthe state of the network. This is done with the following 3 steps:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Create callbacks which will be called when gRPC messages are received from a client."}),"\n",(0,s.jsxs)(t.li,{children:["Register the callbacks with an instance of the ",(0,s.jsx)(t.code,{children:"QueryNetworkStateService"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Add your ",(0,s.jsx)(t.code,{children:"QueryNetworkStateService"})," instance as a gRPC service."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"creating-callbacks",children:"Creating callbacks"}),"\n",(0,s.jsxs)(t.p,{children:["Each supported message in ",(0,s.jsx)(t.code,{children:"QueryNetworkStateService"})," requires a callback, which will be triggered when any client messages are received."]}),"\n",(0,s.jsx)(t.h3,{id:"on_get_current_states",children:"on_get_current_states"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"on_get_current_states"})," callback is triggered for each request for the current states between two date/times, and should return an async iterator of the\ncurrent state events that occurred between those date/times (inclusive)"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"from datetime import datetime\nfrom typing import AsyncGenerator, Iterable\n\nfrom zepben.ewb import CurrentStateEventBatch\n\n\nasync def on_get_current_states(from_datetime: datetime, to_datetime: datetime) -> AsyncGenerator[CurrentStateEventBatch, None]:\n    events = []\n    # build the batch of events\n    yield events\n"})}),"\n",(0,s.jsx)(t.h3,{id:"oncurrentstatesstatus",children:"onCurrentStatesStatus"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"onCurrentStatesStatus"})," callback is triggered for each status response sent by the client. You should expect to receive one of these for every batch\nreturned from ",(0,s.jsx)(t.code,{children:"onGetCurrentStates"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"from zepben.ewb import SetCurrentStatesStatus\n\n\ndef on_current_states_status(event_status: SetCurrentStatesStatus):\n    # Do something with the `eventStatus`.\n"})}),"\n",(0,s.jsx)(t.h3,{id:"onprocessingerror",children:"onProcessingError"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"onProcessingError"})," callback is triggered for any errors in your ",(0,s.jsx)(t.code,{children:"onCurrentStatesStatus"})," callback, or if any [SetCurrentStatesResponse] is for an unknown\nevent status."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def on_processing_error(error: Exception):\n    # Do something with the `error`.\n"})}),"\n",(0,s.jsx)(t.h2,{id:"registering-callbacks",children:"Registering callbacks"}),"\n",(0,s.jsxs)(t.p,{children:["Registering the callbacks with the service is as simple as passing them into the ",(0,s.jsx)(t.code,{children:"QueryNetworkStateService"})," constructor."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"service = QueryNetworkStateService(on_get_current_states, on_current_states_status, on_processing_error)\n"})}),"\n",(0,s.jsx)(t.h2,{id:"registering-the-service",children:"Registering the service"}),"\n",(0,s.jsx)(t.p,{children:"For the above code to have any effect, you need to register the service with a gRPC server. Once this has been done, you should start to receive callbacks for\neach request sent from a gRPC client."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"import grpc\nfrom zepben.protobuf.ns.network_state_pb2_grpc import add_QueryNetworkStateServiceServicer_to_server\n\n\nserver = grpc.aio.server()\nhost = 'localhost:50051'\nserver.add_insecure_port(host)\n\nadd_QueryNetworkStateServiceServicer_to_server(service, server)\n\nawait server.start()\n"})}),"\n",(0,s.jsx)(t.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,s.jsx)(t.p,{children:"Putting each of the steps above together, you can build the scaffold of a working application"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"from datetime import datetime\nfrom typing import AsyncGenerator, Iterable\n\nimport grpc\nfrom zepben.protobuf.ns.network_state_pb2_grpc import add_QueryNetworkStateServiceServicer_to_server\n\nfrom zepben.ewb import CurrentStateEventBatch, QueryNetworkStateService, SetCurrentStatesStatus\n\nclass QueryNetworkStateServiceImpl:\n\n    def __init__(self):\n        self.service = QueryNetworkStateService(self.on_get_current_states, self.on_current_states_status, self.on_processing_error)\n\n    async def on_get_current_states(self, from_datetime: datetime, to_datetime: datetime) -> AsyncGenerator[CurrentStateEventBatch, None]:\n        events = []\n        # build the batch of events\n        yield events\n\n    def on_current_states_status(event_status: SetCurrentStatesStatus):\n        # Do something with the `eventStatus`.\n\n    def on_processing_error(error: Exception):\n        # Do something with the `error`.\n\nasync def main():\n    server = grpc.aio.server()\n    host = 'localhost:50051'\n    server.add_insecure_port(host)\n\n    service = QueryNetworkStateServiceImpl().service\n    add_QueryNetworkStateServiceServicer_to_server(service, server)\n\n    await server.start()\n"})})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},72207:function(e,t,r){r(74848),r(96540)},33021:function(e,t,r){r(74848),r(96540),r(98864)},84429:function(e,t,r){r.d(t,{R:()=>o,x:()=>a});var n=r(96540);let s={},i=n.createContext(s);function o(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);