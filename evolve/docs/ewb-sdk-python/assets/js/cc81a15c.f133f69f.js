"use strict";(self.webpackChunkewb_sdk_python=self.webpackChunkewb_sdk_python||[]).push([["3092"],{66703:function(e,n,s){s.r(n),s.d(n,{metadata:()=>r,default:()=>c,frontMatter:()=>d,contentTitle:()=>a,toc:()=>l,assets:()=>h});var r=JSON.parse('{"id":"sdk-phases","title":"Phases and Feeder Directions","description":"There are three different types of phases stored/calculated by the SDK:","source":"@site/versioned_docs/version-0.42.0/phases.mdx","sourceDirName":".","slug":"/sdk-phases","permalink":"/evolve/docs/ewb-sdk-python/0.42.0/sdk-phases","draft":false,"unlisted":false,"tags":[],"version":"0.42.0","frontMatter":{"id":"sdk-phases","title":"Phases and Feeder Directions"},"sidebar":"someSidebar","previous":{"title":"CIM Services","permalink":"/evolve/docs/ewb-sdk-python/0.42.0/sdk-services"},"next":{"title":"Tracing","permalink":"/evolve/docs/ewb-sdk-python/0.42.0/sdk-tracing"}}'),t=s(74848),i=s(28453);let d={id:"sdk-phases",title:"Phases and Feeder Directions"},a,h={},l=[{value:"Traced Phases",id:"traced-phases",level:2},{value:"Feeder Direction",id:"feeder-direction",level:2},{value:"Previous Versions",id:"previous-versions",level:2}];function o(e){let n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"There are three different types of phases stored/calculated by the SDK:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Phase Type"}),(0,t.jsx)(n.th,{children:"SDK Field"}),(0,t.jsx)(n.th,{children:"Field Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Nominal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Terminal.phases"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PhaseCode"})}),(0,t.jsxs)(n.td,{children:['The nominal phases of the network indicate how the network is connected. The nominal phases can include the "unknown" phases ',(0,t.jsx)(n.code,{children:"X"})," and ",(0,t.jsx)(n.code,{children:"Y"}),". ",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"This is the phase field that you are most likely to be interested in."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Normal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Terminal.normal_phases"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Traced"})}),(0,t.jsx)(n.td,{children:"The normal phases indicate the energised phases of the network in its normal state. There will not be any unknown phases in the normal phases, however; any de-energised areas of the network will not have normal phases."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Current"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Terminal.current_phases"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Traced"})}),(0,t.jsx)(n.td,{children:"The current phases indicate the energised phases of the network in the current state. It has the same caveats as the normal phases."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"There are two different feeder directions calculated by the SDK:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feeder Direction Type"}),(0,t.jsx)(n.th,{children:"SDK Field"}),(0,t.jsx)(n.th,{children:"Field Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Normal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Terminal.normal_feeder_direction"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"FeederDirection"})}),(0,t.jsx)(n.td,{children:"The direction of the feeder head with the network in its normal state."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Current"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Terminal.current_feeder_direction"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"FeederDirection"})}),(0,t.jsx)(n.td,{children:"The direction of the feeder head with the network in its current state."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"traced-phases",children:"Traced Phases"}),"\n",(0,t.jsxs)(n.p,{children:["Traced phases should be considered '",(0,t.jsx)(n.em,{children:"read-only"}),"' (even though they have setters). The traced phases will be automatically set if you load a database from disk,\notherwise you should make use of the ",(0,t.jsx)(n.code,{children:"SetPhases"})," class. If you are implementing network modification algorithms, you can also make use of the ",(0,t.jsx)(n.code,{children:"RemovePhases"}),"\nclass if required."]}),"\n",(0,t.jsx)(n.p,{children:"There are two methods for accessing the traced phases:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["As a ",(0,t.jsx)(n.code,{children:"PhaseCode"}),". If the traced phases do not form a valid phase code this will return ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Per nominal phase."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class PhaseLogger:\n    @staticmethod\n    def log_phases(terminal: Terminal):\n        phase_code = terminal.normal_phases.as_phase_code()\n        if phase_code:\n            print(f"Found phases for {terminal}. nominal: {terminal.phases}, normal: {phase_code}")\n        else:\n            print(f"Found partial phases {terminal}:")\n            for nominalPhase in terminal.phases:\n                print(f"   nominal: {nominalPhase}, normal: {terminal.normal_phases[nominalPhase]}")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"feeder-direction",children:"Feeder Direction"}),"\n",(0,t.jsx)(n.p,{children:"Feeder direction can be set to one of the following values:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Value"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"UPSTREAM"})}),(0,t.jsx)(n.td,{children:"Traversing from this terminal will lead you towards the feeder head."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"DOWNSTREAM"})}),(0,t.jsx)(n.td,{children:"Traversing from this terminal will lead you away from the feeder head."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"BOTH"})}),(0,t.jsx)(n.td,{children:"This terminal is part of a loop and traversing from this terminal can both lead you towards or away from the feeder head."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"NONE"})}),(0,t.jsx)(n.td,{children:"This terminal is not on a feeder. e.g. De-energised sections or EHV."})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"NOTE"})}),": A terminal only has a single feeder direction for each state of the network, so if there is unganged switching, not all nominal phases may\ntrace in the direction specified. A direction of ",(0,t.jsx)(n.code,{children:"BOTH"})," can be formed from some phases tracing ",(0,t.jsx)(n.code,{children:"UPSTREAM"}),", with others tracing ",(0,t.jsx)(n.code,{children:"DOWNSTREAM"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class DirectionLogger:\n    @staticmethod\n    def log_direction(terminal: Terminal):\n        print(f"{terminal}: normal={terminal.normal_feeder_direction}, current={terminal.current_feeder_direction}")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"previous-versions",children:"Previous Versions"}),"\n",(0,t.jsx)(n.p,{children:"Previously, traced phases and feeder directions were stored together and could only be accessed per nominal phase. Below are some examples of converting from\nthe old format to the current:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Python",children:'# Old\nclass PhaseAndDirectionLoggerOld:\n    @staticmethod\n    def log(terminal: Terminal):\n        print(f"{terminal}:")\n        for phase in terminal.phases.single_phases:\n            nps = normal_phases(terminal, phase)\n            cps = current_phases(terminal, phase)\n\n            print(f"   {phase}: n:{nps.phase()}:{nps.direction()}, c:{cps.phase()}:{cps.direction()}")\n\n# Becomes\nclass PhaseAndDirectionLoggerOld:\n    @staticmethod\n    def log(terminal: Terminal):\n        print(f"{terminal}: dn:{terminal.normal_feeder_direction}, dc:{terminal.current_feeder_direction}")\n        for phase in terminal.phases:\n            print(f"   {phase}: n:{terminal.normal_phases[phase]}, c:{terminal.current_phases[phase]}")\n'})})]})}function c(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},28453:function(e,n,s){s.d(n,{R:()=>d,x:()=>a});var r=s(96540);let t={},i=r.createContext(t);function d(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);