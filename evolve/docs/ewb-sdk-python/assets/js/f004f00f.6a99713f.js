"use strict";(self.webpackChunkewb_sdk_python=self.webpackChunkewb_sdk_python||[]).push([["4206"],{13671:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,default:()=>h,frontMatter:()=>s,contentTitle:()=>c,toc:()=>l,assets:()=>a});var r=JSON.parse('{"id":"sdk-consumer","title":"Requesting Models","description":"The API for consuming data from the Evolve data server is currently in alpha and very likely to experience breaking changes","source":"@site/versioned_docs/version-0.36.0/consumer.mdx","sourceDirName":".","slug":"/sdk-consumer","permalink":"/evolve/docs/ewb-sdk-python/0.36.0/sdk-consumer","draft":false,"unlisted":false,"tags":[],"version":"0.36.0","frontMatter":{"id":"sdk-consumer","title":"Requesting Models"},"sidebar":"someSidebar","previous":{"title":"Persisting Models","permalink":"/evolve/docs/ewb-sdk-python/0.36.0/sdk-persistence"}}'),i=t(74848),o=t(28453);t(32614),t(19314);let s={id:"sdk-consumer",title:"Requesting Models"},c,a={},l=[{value:"Connecting to a server",id:"connecting-to-a-server",level:2},{value:"Connecting with HTTPS",id:"connecting-with-https",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Network Hierarchy",id:"network-hierarchy",level:2},{value:"Requesting Identified Objects",id:"requesting-identified-objects",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The API for consuming data from the Evolve data server is currently in alpha and very likely to experience breaking changes\nin the future. Please provide any feedback about this API to ",(0,i.jsx)(n.a,{href:"http://www.zepben.com",children:"Zepben"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["The SDK provides a client to request models to a remote data server via ",(0,i.jsx)(n.a,{href:"https://grpc.io/",children:"gRPC"}),". The service and proto\ndefinitions for this API can be found ",(0,i.jsx)(n.a,{href:"https://github.com/zepben/evolve-grpc",children:"here"}),". An implementation of the consumer\nserver is provided with the Evolve platform data services."]}),"\n",(0,i.jsx)(n.p,{children:"When working with models, it is often impractical to load a whole model to a client due to the size of the data. This\nis generally not a problem however, as most use cases only operate on a small subsection of the model at a time. So, the\nconsumer API provides the ability to request smaller portions of the model quickly and easily. The other benefit to this\nis you can set up many clients in parallel operating on different chunks of the model to reduce the amount of time to\nrun any analytics you may wish to perform across the whole model."}),"\n",(0,i.jsx)(n.h2,{id:"connecting-to-a-server",children:"Connecting to a server"}),"\n",(0,i.jsxs)(n.p,{children:["The library provides four functions, ",(0,i.jsx)(n.code,{children:"connect_insecure()"}),", ",(0,i.jsx)(n.code,{children:"connect_tls()"}),", ",(0,i.jsx)(n.code,{children:"connect_with_password()"})," and ",(0,i.jsx)(n.code,{children:"connect_with_secret()"}),".\n",(0,i.jsx)(n.code,{children:"connect_insecure"})," has arguments: host: str, rpc_port: int\n",(0,i.jsx)(n.code,{children:"connect_tls"})," has arguments: host: str, rpc_port: int, ca_filename: str\n",(0,i.jsx)(n.code,{children:"connect_with_secret"})," has arguments: client_id: str, client_secret: str, conf_address: str, verify_conf: bool/str, verify_auth: bool/str,\nhost: str, rpc_port: int, ca_filename: str,\nand **kwargs: could include audience: str, issuer_domain: str to specify authentication config directly.\n",(0,i.jsx)(n.code,{children:"connect_with_password"})," has arguments: client_id: str, username: str, password: str, conf_address: str, verify_conf: bool/str, verify_auth: bool/str,\nhost: str, rpc_port: int, ca_filename: str,\nand **kwargs: could include audience: str, issuer_domain: str to specify authentication config directly."]}),"\n",(0,i.jsx)(n.p,{children:"The async version is to be used with Python asyncio."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import connect_insecure, Feeder, SyncNetworkConsumerClient, NetworkConsumerClient\n\n# Synchronous\nchannel = connect_insecure(host="localhost", rpc_port=50051)\nclient = SyncNetworkConsumerClient(channel)\nresult = client.get_equipment_container("xxx", Feeder)\n# do stuff with service\nclient.service.get(\'...\')\n\n# Asyncio\nasync with connect_insecure(host="localhost", rpc_port=50051) as channel:\n    client = NetworkConsumerClient(channel)\n    result = await client.get_equipment_container("xxx", Feeder)\n    # do stuff with service\n    client.service.get(\'...\')\n'})}),"\n",(0,i.jsx)(n.h3,{id:"connecting-with-https",children:"Connecting with HTTPS"}),"\n",(0,i.jsx)(n.p,{children:"To connect to a HTTPS server with no auth all that's needed is the CA for the server. If the CA is in your system certificates it should be picked up\nautomatically and the following should suffice:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import connect_tls, SyncNetworkConsumerClient, Feeder\n\nchannel = connect_tls(host="ewb.zepben.com", rpc_port=443)\nclient = SyncNetworkConsumerClient(channel)\nresult = client.get_equipment_container("xxx", Feeder)\nclient.service.get(\'...\')\n'})}),"\n",(0,i.jsx)(n.p,{children:"To specify a CA bundle pass the ca parameter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import connect_tls, SyncNetworkConsumerClient, Feeder\nfrom zepben.protobuf.nc.nc_requests_pb2 import INCLUDE_ENERGIZED_LV_FEEDERS\n\nchannel = connect_tls(host="ewb.zepben.com", rpc_port=443, ca_filename="path/to/ca/bundle")\nclient = SyncNetworkConsumerClient(channel)\n\nresult = client.get_equipment_container("xxx", Feeder)\n# The Feeder container only contains HV/MV equipment. To include LV, use the following line instead:\n# result = client.get_equipment_container("xxx", Feeder, include_energized_containers=INCLUDE_ENERGIZED_LV_FEEDERS)\n\nclient.service.get(\'...\')\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If client authentication is required by the server, use the underlying ",(0,i.jsx)(n.code,{children:"GrpcChannelBuilder"})," class instead:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import GrpcChannelBuilder, SyncNetworkConsumerClient, Feeder\nfrom zepben.protobuf.nc.nc_requests_pb2 import INCLUDE_ENERGIZED_LV_FEEDERS\n\nchannel = (\n    GrpcChannelBuilder()\n    .for_address("ewb.zepben.com", 443)\n    .make_secure("path/to/ca/bundle", "path/to/cert/chain", "path/to/private/key")\n    .build()\n)\nclient = SyncNetworkConsumerClient(channel)\n\nresult = client.get_equipment_container("xxx", Feeder)\n# The Feeder container only contains HV/MV equipment. To include LV, use the following line instead:\n# result = client.get_equipment_container("xxx", Feeder, include_energized_containers=INCLUDE_ENERGIZED_LV_FEEDERS)\n\nclient.service.get(\'...\')\n'})}),"\n",(0,i.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsxs)(n.p,{children:["Password Credentials and Client credentials OAuth2 flows are supported through the ",(0,i.jsx)(n.code,{children:"connect_with_secret"})," and ",(0,i.jsx)(n.code,{children:"connect_with_password"})," functions respectively:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import connect_with_password, connect_with_secret, SyncNetworkConsumerClient\n\n# Client credentials configuration\nchannel = connect_with_secret(client_id="some_client_id", client_secret="some_client_secret", host="ewb.zepben.com", rpc_port=443,\n                              conf_address="https://ewb.zepben.com/ewb/auth", verify_conf="path to certificate chain for auth params", \n                              ca_filename="path to certificate for grpc queries")\nclient = SyncNetworkConsumerClient(channel)\n# ...\n\n# Password credentials configuration\nchannel = connect_with_password(client_id="some_client_id", username="user@email.com", password="password1", host="ewb.zepben.com", rpc_port=443,\n                                conf_address="https://ewb.zepben.com/ewb/auth")\nclient = SyncNetworkConsumerClient(channel)\n# ...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"audience"})," and ",(0,i.jsx)(n.code,{children:"issuer_domain"})," are provided as keyword arguments, they will be used to construct a ",(0,i.jsx)(n.code,{children:"ZepbenTokenFetcher"})," directly without fetching them from\n",(0,i.jsx)(n.code,{children:"conf_address"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If running in Azure we also support auth via Azure managed identities using ",(0,i.jsx)(n.code,{children:"connect_with_identity"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import connect_with_identity, SyncNetworkConsumerClient\n\n# Client credentials configuration\nchannel = connect_with_identity(host="ewb.zepben.com", rpc_port=443, identity_url="http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=<SOME_IDENTIFIER>")\nclient = SyncNetworkConsumerClient(channel)\n# ...\n'})}),"\n",(0,i.jsx)(n.h2,{id:"network-hierarchy",children:"Network Hierarchy"}),"\n",(0,i.jsxs)(n.p,{children:["The network can be built with a hierarchy as discussed earlier ",(0,i.jsx)(n.a,{href:"/evolve/docs/ewb-sdk-python/0.36.0/#network-hierarchy",children:"here"}),". This allows you\nto easily identify and request smaller chunks of the network so you can focus on areas of concern. Here is an example\nof how to request the network hierarchy and print it out as a tree to the console."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from zepben.evolve import SyncNetworkConsumerClient\n\ndef print_network_hierarchy(client: SyncNetworkConsumerClient):\n    hierarchy = client.get_network_hierarchy().result\n    if not hierarchy:\n        return\n    for region in hierarchy.geographical_regions:\n        print(f"- {region.name} [{region.mrid}]")\n        for sub_region in region.sub_geographical_regions:\n            print(f"  |- {sub_region.name} [{sub_region.mrid}]")\n            for substation in sub_region.substations:\n                print(f"    |- {sub_region.name} [{sub_region.mrid}]")\n                for feeder in substation.feeders:\n                    print(f"      |- {feeder.name} [{feeder.mrid}]")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Each item from the hierarchy result contains an identified object mRID and it's name. This simplified data structure\nenables you to do things like easily build a suitable UI component allowing a user to select a portion of the network\nthey wish to use, without needing to pull back large amounts of full object data."}),"\n",(0,i.jsx)(n.h2,{id:"requesting-identified-objects",children:"Requesting Identified Objects"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"The *ConsumerClient APIs will take care of this for you, and you typically only need these functions if you're\ndeveloping the consumer client APIs themselves. Make sure what you want to achieve isn't already covered by the\nAPI before delving into this code."})}),"\n",(0,i.jsx)(n.p,{children:"Identified objects can be requested to build a model client side. When identified objects are loaded, any referenced\nobjects that have not been previously requested need to be requested explicitly."}),"\n",(0,i.jsxs)(n.p,{children:["To find the references that need to be requested you can use the ",(0,i.jsx)(n.a,{href:"/evolve/docs/ewb-sdk-python/0.36.0/sdk-services#deferred-references",children:"deferred reference"}),"\nfunctions on the service provided when requesting identified objects."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from zepben.evolve import NetworkService, SyncNetworkConsumerClient, resolver\n\ndef get_with_base_voltage(service: NetworkService, client: SyncNetworkConsumerClient, mrid: str):\n    equipment = client.get_identified_object(mrid).result\n    if not equipment:\n        return\n\n    # Get all base voltage relationships\n    mrids = list(service.get_unresolved_reference_mrids_by_resolver(resolver.ce_base_voltage(equipment)))\n    if mrids:\n        client.get_identified_object(mrids[0])\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also query the services UnresolvedReferences in the following ways:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# To get unresolved references pointing from `equipment` to other objects:\nfor ref in service.get_unresolved_references_from(equipment.mrid):\n    await client.get_identified_object(service, ref.to_mrid)\n\n# To get unresolved references pointing to `equipment`:\nfor ref in service.get_unresolved_references_to(equipment.mrid):\n    await client.get_identified_object(service, ref.from_ref.mrid)\n\n# Get all unresolved references. Note this will iterate over every unresolved reference and is likely undesirable. You should prefer to use the above two methods.\nfor ref in service.unresolved_references():\n    await client.get_identified_object(service, ref.to_mrid)\n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},19314:function(e,n,t){t(74848),t(96540)},32614:function(e,n,t){t(74848),t(96540),t(19863)},28453:function(e,n,t){t.d(n,{R:()=>s,x:()=>c});var r=t(96540);let i={},o=r.createContext(i);function s(e){let n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);