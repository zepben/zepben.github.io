"use strict";(self.webpackChunkevolve_sdk_jvm_doco=self.webpackChunkevolve_sdk_jvm_doco||[]).push([[6510],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>v});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(t),p=a,v=d["".concat(s,".").concat(p)]||d[p]||h[p]||o;return t?r.createElement(v,l(l({ref:n},u),{},{components:t})):r.createElement(v,l({ref:n},u))}));function v(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=p;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[d]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<o;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>l});var r=t(67294),a=t(34334);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:n,hidden:t,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,l),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>w});var r=t(87462),a=t(67294),o=t(34334),l=t(12466),i=t(16550),s=t(91980),c=t(67392),u=t(50012);function d(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}function h(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:d(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function v(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,s._X)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=h(e),[l,i]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=r.find((e=>e.default)))?n:r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[s,c]=v({queryString:t,groupId:r}),[d,m]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,o]=(0,u.Nk)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),f=(()=>{const e=null!=s?s:d;return p({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{f&&i(f)}),[f]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);i(e),c(e),m(e)}),[c,m,o]),tabValues:o}}var f=t(72389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:n,block:t,selectedValue:i,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.o5)(),h=e=>{const n=e.currentTarget,t=u.indexOf(n),r=c[t].value;r!==i&&(d(n),s(r))},p=e=>{var n;let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{var r;const n=u.indexOf(e.currentTarget)+1;t=null!=(r=u[n])?r:u[0];break}case"ArrowLeft":{var a;const n=u.indexOf(e.currentTarget)-1;t=null!=(a=u[n])?a:u[u.length-1];break}}null==(n=t)||n.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:l}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,key:n,ref:e=>u.push(e),onKeyDown:p,onClick:h},l,{className:(0,o.Z)("tabs__item",g.tabItem,null==l?void 0:l.className,{"tabs__item--active":i===n})}),null!=t?t:n)})))}function k(e){let{lazy:n,children:t,selectedValue:r}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function y(e){const n=m(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",g.tabList)},a.createElement(b,(0,r.Z)({},e,n)),a.createElement(k,(0,r.Z)({},e,n)))}function w(e){const n=(0,f.Z)();return a.createElement(y,(0,r.Z)({key:String(n)},e))}},60624:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>v,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(87462),a=(t(67294),t(3905)),o=t(74866),l=t(85162);const i={id:"sdk-consumer",title:"Requesting Models"},s=void 0,c={unversionedId:"sdk-consumer",id:"version-0.6.0/sdk-consumer",title:"Requesting Models",description:"The API for consuming data from the Evolve data server is currently in alpha and very likely to experience breaking changes",source:"@site/versioned_docs/version-0.6.0/consumer.mdx",sourceDirName:".",slug:"/sdk-consumer",permalink:"/evolve/docs/jvm-sdk/0.6.0/sdk-consumer",draft:!1,tags:[],version:"0.6.0",frontMatter:{id:"sdk-consumer",title:"Requesting Models"},sidebar:"version-0.6.0/someSidebar",previous:{title:"Persisting Models",permalink:"/evolve/docs/jvm-sdk/0.6.0/sdk-persistence"}},u={},d=[{value:"Connecting to a server",id:"connecting-to-a-server",level:2},{value:"Network Hierarchy",id:"network-hierarchy",level:2},{value:"Requesting Identififed Objects",id:"requesting-identififed-objects",level:2}],h={toc:d},p="wrapper";function v(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"The API for consuming data from the Evolve data server is currently in alpha and very likely to experience breaking changes\nin the future. Please provide any feedback about this API to ",(0,a.kt)("a",{parentName:"p",href:"https://www.zepben.com"},"Zepben"),".")),(0,a.kt)("p",null,"The SDK provides a client to request models to a remote data server via ",(0,a.kt)("a",{parentName:"p",href:"https://grpc.io/"},"gRPC"),". The service and proto\ndefinitions for this API can be found ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zepben/evolve-grpc"},"here"),". An implementation of the consumer\nserver is provided with the Evolve platform data services."),(0,a.kt)("p",null,"When working with models, it is often impractical to load a whole model to a client due to the size of the data. This\nis generally not a problem however, as most use cases only operate on a small subsection of the model at a time. So, the\nconsumer API provides the ability to request smaller portions of the model quickly and easily. The other benefit to this\nis you can set up many clients in parallel operating on different chunks of the model to reduce the amount of time to\nrun any analytics you may wish to perform across the whole model."),(0,a.kt)("h2",{id:"connecting-to-a-server"},"Connecting to a server"),(0,a.kt)(o.Z,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// Insecure\nGrpcChannel channel = GrpcChannelFactory.create(new ConnectionConfig("localhost", 50051));\n\nNetworkConsumerClient client = new NetworkConsumerClient(channel);\nNetworkService ns = new NetworkService();\nGrpcResult result = client.getFeeder(ns).throwOnError();\n\n\n// With SSL\nGrpcChannel channel = GrpcChannelFactory.create(new ConnectionConfig("localhost", 50051, true, "ca.cert"));\n\nNetworkConsumerClient client = new NetworkConsumerClient(channel);\nNetworkService ns = new NetworkService();\nGrpcResult result = client.getFeeder(ns).throwOnError();\n\n\n// With SSL and OAuth2. Note that you should never connect to a non-SSL server while using OAuth2, as you will be vulnerable to MITM attacks.\nGrpcChannel channel = GrpcChannelFactory.create(new ConnectionConfig("localhost", 50051, true, "ca.cert"));\n\n// Create CallCredentials using a configuration URL. This configuration endpoint will often be provided by the service you are connecting to.\nJwtCredentials creds = EvolveCallCredentials.create(\n    "<client_id>",\n    "<client_secret>",\n    "<ewb_auth_config_URL>"\n);\n\n// Or create them with an AuthConfig if a configuration endpoint doesn\'t exist.\nJwtCredentials creds = EvolveCallCredentials.create(\n    "<client_id>",\n    "<client_secret>",\n    new AuthConfig(tokenUrl="https://zepben.au.auth0.com/oauth/token", audience="https://evolve/", authType=AuthType.AUTH0)\n);\n\nNetworkConsumerClient client = new NetworkConsumerClient(channel, creds);\nNetworkService ns = new NetworkService();\nGrpcResult result = client.getFeeder(ns).throwOnError();\n\n\n// With SSL and client authentication\nGrpcChannel channel = GrpcChannelFactory.create(new ConnectionConfig("localhost", 50051, true, "ca.cert", "path/to/signed.cert", "path/to/private.key"));\n\nNetworkConsumerClient client = new NetworkConsumerClient(channel);\nNetworkService ns = new NetworkService();\nGrpcResult result = client.getFeeder(ns).throwOnError();\n'))),(0,a.kt)(l.Z,{value:"kotlin",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Insecure\nval channel = GrpcChannelFactory.create(ConnectionConfig("localhost", 50051))\n\nval client = NetworkConsumerClient(channel)\nval ns = NetworkService()\nval result = client.getFeeder(ns).throwOnError()\n\n\n// With just SSL\nval channel = GrpcChannelFactory.create(ConnectionConfig("localhost", 50051, true, trustCertPath = "path/to/zepben/ca.cert"))\n\nval client = NetworkConsumerClient(channel)\nval ns = NetworkService()\nval result = client.getFeeder(ns).throwOnError()\n\n\n// With SSL and OAuth2. Note that you should never connect to a non-SSL server while using OAuth2, as you will be vulnerable to MITM attacks.\nval channel = GrpcChannelFactory.create(ConnectionConfig("localhost", 50051, true, trustCertPath = "path/to/zepben/ca.cert"))\n\n// Create CallCredentials using a configuration URL. This configuration endpoint will often be provided by the service you are connecting to.\nval creds = EvolveCallCredentials.create(\n    "<client_id>",\n    "<client_secret>",\n    "<ewb_auth_config_URL>"\n)\n\n// Or create them with an AuthConfig if a configuration endpoint doesn\'t exist.\nval creds = EvolveCallCredentials.create(\n    "<client_id>",\n    "<client_secret>",\n    AuthConfig(tokenUrl="https://zepben.au.auth0.com/oauth/token", audience="https://evolve/", authType=AuthType.AUTH0)\n)\n\nval client = NetworkConsumerClient(channel, creds)\nval ns = NetworkService()\nval result = client.getFeeder(ns).throwOnError()\n\n\n// With SSL and client authentication\nval channel = GrpcChannelFactory.create(ConnectionConfig("localhost", 50051, true, trustCertPath = "path/to/zepben/ca.cert", authCertPath = "path/to/signed.cert", authKeyPath = "path/to/private.key"))\n\nval client = NetworkConsumerClient(channel)\nval ns = NetworkService()\nval result = client.getFeeder(ns).throwOnError()\n')))),(0,a.kt)("h2",{id:"network-hierarchy"},"Network Hierarchy"),(0,a.kt)("p",null,"The network can be built with a hierarchy as discussed earlier ",(0,a.kt)("a",{parentName:"p",href:"/evolve/docs/jvm-sdk/0.6.0/#network-hierarchy"},"here"),". This allows you\nto easily identify and request smaller chunks of the network so you can focus on areas of concern. Here is an example\nof how to request the network hierarchy and print it out as a tree to the console."),(0,a.kt)(o.Z,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'void printNetworkHierarchy(NetworkConsumerClient client) {\n    NetworkHierarchy hierarchy = client.getNetworkHierarchy().getResult();\n    if (hierarchy == null)\n        return;\n\n    hierarchy.getGeographicalRegions().values().forEach(region -> {\n        System.out.println(String.format("- %s [%s]", region.getName(), region.getMRID()));\n        region.getSubGeographicalRegions().values().forEach(subRegion -> {\n            System.out.println(String.format("  |- %s [%s]", subRegion.getName(), subRegion.getMRID()));\n            subRegion.getSubstations().values().forEach(substation -> {\n                System.out.println(String.format("    |- %s [%s]", substation.getName(), substation.getMRID()));\n                substation.getFeeders().values().forEach(feeder -> {}\n                    System.out.println(String.format("      |- %s [%s]", feeder.getName(), feeder.getMRID()));\n                });\n            });\n        });\n    });\n}\n'))),(0,a.kt)(l.Z,{value:"kotlin",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun printNetworkHierarchy(client: NetworkConsumerClient) {\n    val hierarchy: NetworkHierarchy = client.getNetworkHierarchy().result ?: return\n    hierarchy.geographicalRegions.values.forEach { region ->\n        println("- ${region.name} [${region.mRID}]")\n        region.subGeographicalRegions.values.forEach { subRegion ->\n            println("  |- ${subRegion.name} [${subRegion.mRID}]")\n            subRegion.substations.values.forEach { substation ->\n                println("    |- ${substation.name} [${substation.mRID}]")\n                substation.feeders.values.forEach { feeder ->\n                    println("      |- ${feeder.name} [${feeder.mRID}]")\n                }\n            }\n        }\n    }\n}\n')))),(0,a.kt)("p",null,"Each item from the hierarchy result contains an identified object mRID and it's name. This simplified data structure\nenables you to do things like easily build a suitable UI component allowing a user to select a portion of the network\nthey wish to use, without needing to pull back large amounts of full object data."),(0,a.kt)("h2",{id:"requesting-identififed-objects"},"Requesting Identififed Objects"),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"The *ConsumerClient APIs will take care of this for you, and you typically only need these functions if you're\ndeveloping the consumer client APIs themselves. Make sure what you want to achieve isn't already covered by the\nAPI before delving into this code.")),(0,a.kt)("p",null,"Identified objects can be requested to build a model client side. When identified objects are loaded, any referenced\nobjects that have not been previously requested need to be requested explicitly."),(0,a.kt)("p",null,"To find the mRIDs of any references that need to be requested you can use the ",(0,a.kt)("a",{parentName:"p",href:"/evolve/docs/jvm-sdk/0.6.0/sdk-services#deferred-references"},"deferred reference"),"\nfunctions on the service provided when requesting identified objects."),(0,a.kt)(o.Z,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"void getWithBaseVoltage(NetworkService service, NetworkConsumerClient client, String mrid) {\n    IdentifiedObject equipment = client.getIdentifiedObject(service, mrid).getResult();\n    if (equipment == null || !(equipment instanceof ConductingEquipment)) {\n        return;\n    }\n    \n    Set<String> mrids = service.getUnresolvedReferenceMrids(Resolvers.baseVoltage(equipment));\n    if (!mrids.isEmpty()) {\n        client.getIdentifiedObject(service, mrids.iterator().next());\n    }\n}\n"))),(0,a.kt)(l.Z,{value:"kotlin",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun getWithBaseVoltage(service: NetworkService, client: NetworkConsumerClient, mrid: String) {\n    val equipment = client.getIdentifiedObject(service, mrid).result\n    if (equipment == null || equipment !is ConductingEquipment) {\n        return\n    }\n\n    service.getUnresolvedReferenceMrids(Resolvers.baseVoltage(equipment)).firstOrNull()\n        ?.let { client.getIdentifiedObject(service, it) }\n}\n")))),(0,a.kt)("p",null,"You can also query the services UnresolvedReferences in the following ways:"),(0,a.kt)(o.Z,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'String mrid = "feeder1";\n\n// To get unresolved references pointing from `equipment` to other objects\nList<UnresolvedReferences> references = service.getUnresolvedReferencesFrom(mrid);\n\nfor (UnresolvedReference ref: references) {\n    client.getIdentifiedObject(service, ref.toMrid)\n}\n\n// To get unresolved references pointing to `equipment`\nreferences = service.getUnresolvedReferencesFrom(mrid);\n\nfor (UnresolvedReference ref: references) {\n    client.getIdentifiedObject(service, ref.from.mRID)\n}\n'))),(0,a.kt)(l.Z,{value:"kotlin",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val mrid = "feeder1"\n\nservice.getUnresolvedReferencesFrom(mrid).forEach {\n    client.getIdentifiedObject(service, ref.toMrid)\n}\n\nservice.getUnresolvedReferencesTo(mrid).forEach {\n    client.getIdentifiedObject(service, ref.from.mRID)\n}\n')))))}v.isMDXComponent=!0}}]);