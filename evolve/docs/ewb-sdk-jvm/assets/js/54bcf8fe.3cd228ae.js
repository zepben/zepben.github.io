"use strict";(self.webpackChunkewb_sdk_jvm=self.webpackChunkewb_sdk_jvm||[]).push([["9477"],{86323:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,default:()=>m,frontMatter:()=>o,contentTitle:()=>c,toc:()=>h,assets:()=>d});var t=JSON.parse('{"id":"sdk-phases","title":"Phases and Feeder Directions","description":"Introduction","source":"@site/versioned_docs/version-0.25.0/phases.mdx","sourceDirName":".","slug":"/sdk-phases","permalink":"/evolve/docs/ewb-sdk-jvm/0.25.0/sdk-phases","draft":false,"unlisted":false,"tags":[],"version":"0.25.0","frontMatter":{"id":"sdk-phases","title":"Phases and Feeder Directions"},"sidebar":"someSidebar","previous":{"title":"CIM Services","permalink":"/evolve/docs/ewb-sdk-jvm/0.25.0/sdk-services"},"next":{"title":"Tracing","permalink":"/evolve/docs/ewb-sdk-jvm/0.25.0/sdk-tracing"}}'),s=r(74848),a=r(28453),l=r(78010),i=r(57250);let o={id:"sdk-phases",title:"Phases and Feeder Directions"},c,d={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Traced Phases",id:"traced-phases",level:2},{value:"Feeder Direction",id:"feeder-direction",level:2},{value:"Previous Versions",id:"previous-versions",level:2}];function u(e){let n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"There are three different types of phases stored/calculated by the SDK:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Phase Type"}),(0,s.jsx)(n.th,{children:"SDK Field"}),(0,s.jsx)(n.th,{children:"Field Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Nominal"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Terminal.phases"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PhaseCode"})}),(0,s.jsxs)(n.td,{children:['The nominal phases of the network indicate how the network is connected. The nominal phases can include the "unknown" phases ',(0,s.jsx)(n.code,{children:"X"})," and ",(0,s.jsx)(n.code,{children:"Y"}),". ",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"This is the phase field that you are most likely to be interested in."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Normal"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Terminal.normalPhases"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PhaseStatus"})}),(0,s.jsx)(n.td,{children:"The normal phases indicate the energised phases of the network in its normal state. There will not be any unknown phases in the normal phases, however; any de-energised areas of the network will not have normal phases."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Current"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Terminal.currentPhases"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PhaseStatus"})}),(0,s.jsx)(n.td,{children:"The current phases indicate the energised phases of the network in the current state. It has the same caveats as the normal phases."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"There are two different feeder directions calculated by the SDK:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feeder Direction Type"}),(0,s.jsx)(n.th,{children:"SDK Field"}),(0,s.jsx)(n.th,{children:"Field Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Normal"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Terminal.normalFeederDirection"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FeederDirection"})}),(0,s.jsx)(n.td,{children:"The direction of the feeder head with the network in its normal state."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Current"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Terminal.currentFeederDirection"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FeederDirection"})}),(0,s.jsx)(n.td,{children:"The direction of the feeder head with the network in its current state."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"traced-phases",children:"Traced Phases"}),"\n",(0,s.jsxs)(n.p,{children:["Traced phases should be considered '",(0,s.jsx)(n.em,{children:"read-only"}),"' (even though they have setters). The traced phases will be automatically set if you load a database from disk,\notherwise you should make use of the ",(0,s.jsx)(n.code,{children:"SetPhases"})," class. If you are implementing network modification algorithms, you can also make use of the ",(0,s.jsx)(n.code,{children:"RemovePhases"}),"\nclass if required."]}),"\n",(0,s.jsx)(n.p,{children:"There are two methods for accessing the traced phases:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["As a ",(0,s.jsx)(n.code,{children:"PhaseCode"}),". If the traced phases do not form a valid phase code this will return ",(0,s.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Per nominal phase."}),"\n"]}),"\n",(0,s.jsxs)(l.A,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],children:[(0,s.jsx)(i.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class PhaseLogger {\n    void logPhases(Terminal terminal) {\n        @Nullable PhaseCode phaseCode = terminal.getNormalPhases().asPhaseCode();\n        if (phaseCode != null)\n            System.out.printf("Found phases for %s. nominal: %s, normal: %s\\n", terminal, terminal.getPhases(), phaseCode);\n        else {\n            System.out.printf("Found partial phases %s:\\n", terminal);\n            terminal.getPhases().forEach(nominalPhase -> {\n                System.out.printf("   nominal: %s, normal: %s\\n", nominalPhase, terminal.getNormalPhases().get(nominalPhase));\n            });\n        }\n    }\n}\n'})})}),(0,s.jsx)(i.A,{value:"kotlin",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class PhaseLogger {\n    fun logPhases(terminal: Terminal) {\n        val phaseCode = terminal.normalPhases.asPhaseCode()\n        if (phaseCode != null)\n            println("Found phases for $terminal. nominal: ${terminal.phases}, normal: $phaseCode")\n        else {\n            println("Found partial phases $terminal:")\n            terminal.phases.forEach {\n                println("   nominal: $it, normal: ${terminal.normalPhases[it]}")\n            }\n        }\n    }\n}\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"feeder-direction",children:"Feeder Direction"}),"\n",(0,s.jsx)(n.p,{children:"Feeder direction can be set to one of the following values:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UPSTREAM"})}),(0,s.jsx)(n.td,{children:"Traversing from this terminal will lead you towards the feeder head."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DOWNSTREAM"})}),(0,s.jsx)(n.td,{children:"Traversing from this terminal will lead you away from the feeder head."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BOTH"})}),(0,s.jsx)(n.td,{children:"This terminal is part of a loop and traversing from this terminal can both lead you towards or away from the feeder head."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"NONE"})}),(0,s.jsx)(n.td,{children:"This terminal is not on a feeder. e.g. De-energised sections or EHV."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"NOTE"})}),": A terminal only has a single feeder direction for each state of the network, so if there is unganged switching, not all nominal phases may\ntrace in the direction specified. A direction of ",(0,s.jsx)(n.code,{children:"BOTH"})," can be formed from some phases tracing ",(0,s.jsx)(n.code,{children:"UPSTREAM"}),", with others tracing ",(0,s.jsx)(n.code,{children:"DOWNSTREAM"}),"."]}),"\n",(0,s.jsxs)(l.A,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],children:[(0,s.jsx)(i.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class DirectionLogger {\n    void logDirection(Terminal terminal) {\n        System.out.printf("%s: normal=%s, current=%s\\n", terminal, terminal.getNormalFeederDirection(), terminal.getCurrentFeederDirection());\n    }\n}\n'})})}),(0,s.jsx)(i.A,{value:"kotlin",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class DirectionLogger {\n    fun logDirection(terminal: Terminal) {\n        println("$terminal: normal=${terminal.normalFeederDirection}, current=${terminal.currentFeederDirection}")\n    }\n}\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"previous-versions",children:"Previous Versions"}),"\n",(0,s.jsx)(n.p,{children:"Previously, traced phases and feeder directions were stored together and could only be accessed per nominal phase. Below are some examples of converting from\nthe old format to the current:"}),"\n",(0,s.jsxs)(l.A,{groupId:"code-example",defaultValue:"java",values:[{label:"Java",value:"java"},{label:"Kotlin",value:"kotlin"}],children:[(0,s.jsx)(i.A,{value:"java",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Old\nclass PhaseAndDirectionLoggerOld {\n    void log(Terminal terminal) {\n        System.out.printf("%s:\\n", terminal);\n        terminal.getPhases().singlePhases().forEach(phase -> {\n            PhaseStatus nps = terminal.normalPhases(phase);\n            PhaseStatus cps = terminal.currentPhases(phase);\n\n            System.out.printf("   %s: n:%s:%s, c:%s:%s\\n", phase, nps.getPhase(), nps.getDirection(), cps.getPhase(), cps.getDirection());\n        });\n    }\n}\n\n// Becomes\nclass PhaseAndDirectionLoggerOld {\n    void log(Terminal terminal) {\n        System.out.printf("%s: dn:%s, dc:%s:\\n", terminal, terminal.getNormalFeederDirection(), terminal.getCurrentFeederDirection());\n        terminal.getPhases().forEach(phase -> {\n            System.out.printf("   %s: n:%s, c:%s\\n", phase, terminal.getNormalPhases().get(phase), terminal.getCurrentPhases().get(phase));\n        });\n    }\n}\n'})})}),(0,s.jsx)(i.A,{value:"kotlin",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Old\nclass PhaseAndDirectionLoggerOld {\n    fun log(terminal: Terminal) {\n        println("$terminal:")\n        terminal.phases.singlePhases().forEach{\n            val nps = terminal.normalPhases(it)\n            val cps = terminal.currentPhases(it)\n\n            println("   $it: n:${nps.phase}:${nps.direction}, c:${cps.phase}:${cps.direction}")\n        }\n    }\n}\n\n// Becomes\ninternal class PhaseAndDirectionLoggerOld {\n    fun log(terminal: Terminal) {\n        println("$terminal: dn:${terminal.normalFeederDirection}, dc:${terminal.currentFeederDirection}:")\n        terminal.phases.forEach {\n            println("   $it: n:${terminal.normalPhases[it]}, c:${terminal.currentPhases[it]}")\n        }\n    }\n}\n'})})})]})]})}function m(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},57250:function(e,n,r){r.d(n,{A:()=>a});var t=r(74848);r(96540);var s=r(34164);function a(e){let{children:n,hidden:r,className:a}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,s.A)("tabItem_Ymn6",a),hidden:r,children:n})}},78010:function(e,n,r){r.d(n,{A:()=>b});var t=r(74848),s=r(96540),a=r(34164),l=r(28584),i=r(56347),o=r(99989),c=r(96629),d=r(80618),h=r(41367);function u(e){var n,r;return null!=(r=null==(n=s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error("Docusaurus error: Bad <Tabs> child <".concat("string"==typeof e.type?e.type:e.type.name,'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.'))}))?void 0:n.filter(Boolean))?r:[]}function m(e){let{value:n,tabValues:r}=e;return r.some(e=>e.value===n)}var p=r(19863);function f(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{},t=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),t.forEach(function(n){var t;t=r[n],n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t})}return e}function j(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):(function(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r.push.apply(r,t)}return r})(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}),e}function x(e){let{className:n,block:r,selectedValue:s,selectValue:i,tabValues:o}=e,c=[],{blockElementScrollPositionUntilNextRender:d}=(0,l.a_)(),h=e=>{let n=e.currentTarget,r=o[c.indexOf(n)].value;r!==s&&(d(n),i(r))},u=e=>{var n,r;let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let r=c.indexOf(e.currentTarget)+1;t=null!=(n=c[r])?n:c[0];break}case"ArrowLeft":{let n=c.indexOf(e.currentTarget)-1;t=null!=(r=c[n])?r:c[c.length-1]}}null==t||t.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":r},n),children:o.map(e=>{let{value:n,label:r,attributes:l}=e;return(0,t.jsx)("li",j(f({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>{c.push(e)},onKeyDown:u,onClick:h},l),{className:(0,a.A)("tabs__item","tabItem_LNqP",null==l?void 0:l.className,{"tabs__item--active":s===n}),children:null!=r?r:n}),n)})})}function v(e){let{lazy:n,children:r,selectedValue:l}=e,i=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){let e=i.find(e=>e.props.value===l);return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:i.map((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==l}))})}function g(e){let n=function(e){let n,{defaultValue:r,queryString:t=!1,groupId:a}=e,l=function(e){let{values:n,children:r}=e;return(0,s.useMemo)(()=>{let e=null!=n?n:u(r).map(e=>{let{props:{value:n,label:r,attributes:t,default:s}}=e;return{value:n,label:r,attributes:t,default:s}}),t=(0,d.XI)(e,(e,n)=>e.value===n.value);if(t.length>0)throw Error('Docusaurus error: Duplicate values "'.concat(t.map(e=>e.value).join(", "),'" found in <Tabs>. Every value needs to be unique.'));return e},[n,r])}(e),[p,f]=(0,s.useState)(()=>(function(e){var n;let{defaultValue:r,tabValues:t}=e;if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!m({value:r,tabValues:t}))throw Error('Docusaurus error: The <Tabs> has a defaultValue "'.concat(r,'" but none of its children has the corresponding value. Available values are: ').concat(t.map(e=>e.value).join(", "),". If you intend to show no default tab, use defaultValue={null} instead."));return r}let s=null!=(n=t.find(e=>e.default))?n:t[0];if(!s)throw Error("Unexpected error: 0 tabValues");return s.value})({defaultValue:r,tabValues:l})),[j,x]=function(e){let{queryString:n=!1,groupId:r}=e,t=(0,i.W6)(),a=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:n,groupId:r});return[(0,c.aZ)(a),(0,s.useCallback)(e=>{var n,r;if(!a)return;let s=new URLSearchParams(t.location.search);s.set(a,e),t.replace((n=function(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{},t=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(t=t.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),t.forEach(function(n){var t;t=r[n],n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t})}return e}({},t.location),r=r={search:s.toString()},Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):(function(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r.push.apply(r,t)}return r})(Object(r)).forEach(function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}),n))},[a,t])]}({queryString:t,groupId:a}),[v,g]=function(e){let{groupId:n}=e,r=n?"docusaurus.tab.".concat(n):null,[t,a]=(0,h.Dv)(r);return[t,(0,s.useCallback)(e=>{r&&a.set(e)},[r,a])]}({groupId:a}),b=m({value:n=null!=j?j:v,tabValues:l})?n:null;return(0,o.A)(()=>{b&&f(b)},[b]),{selectedValue:p,selectValue:(0,s.useCallback)(e=>{if(!m({value:e,tabValues:l}))throw Error("Can't select invalid tab value=".concat(e));f(e),x(e),g(e)},[x,g,l]),tabValues:l}}(e);return(0,t.jsxs)("div",{className:(0,a.A)("tabs-container","tabList__CuJ"),children:[(0,t.jsx)(x,f({},n,e)),(0,t.jsx)(v,f({},n,e))]})}function b(e){let n=(0,p.A)();return(0,t.jsx)(g,j(f({},e),{children:u(e.children)}),String(n))}},28453:function(e,n,r){r.d(n,{R:()=>l,x:()=>i});var t=r(96540);let s={},a=t.createContext(s);function l(e){let n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);