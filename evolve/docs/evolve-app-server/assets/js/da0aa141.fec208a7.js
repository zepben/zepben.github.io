"use strict";(self.webpackChunkewb_app_server_doco=self.webpackChunkewb_app_server_doco||[]).push([[733],{5770:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=i(7462),r=(i(7294),i(3905));const a={id:"metrics-api",slug:"/api/graphql/metrics",title:"Metrics",hide_title:!0},o=void 0,s={unversionedId:"api/graphql/metrics-api",id:"api/graphql/metrics-api",title:"Metrics",description:"Metrics API",source:"@site/docs/api/graphql/metrics.mdx",sourceDirName:"api/graphql",slug:"/api/graphql/metrics",permalink:"/evolve/docs/evolve-app-server/next/api/graphql/metrics",draft:!1,tags:[],version:"current",frontMatter:{id:"metrics-api",slug:"/api/graphql/metrics",title:"Metrics",hide_title:!0},sidebar:"sidebar",previous:{title:"Network",permalink:"/evolve/docs/evolve-app-server/next/api/network"}},l={},p=[{value:"Metrics API",id:"metrics-api",level:2},{value:"Queries",id:"queries",level:2},{value:"Types",id:"types",level:2}],c={toc:p},d="wrapper";function h(e){let{components:t,...i}=e;return(0,r.kt)(d,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"metrics-api"},"Metrics API"),(0,r.kt)("p",null,"The Metrics component of the GraphQL API grants read-access to the metrics database. The GraphQL API is served at ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/graphql"),"."),(0,r.kt)("h2",{id:"queries"},"Queries"),(0,r.kt)("p",null,"The Metrics component of the GraphQL API comprises the following queries:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getAllJobs: [IngestionJob]"),": Gets all ingestion jobs' ID and metadata in reverse-chronological order."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getNewestJob: IngestionJob?"),": Gets the newest ingestion job's ID and metadata. If no jobs are in the metrics database, this returns null."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getSources(jobId: string): [JobSource]"),": Gets data sources for an ingestion job by ID."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getMetrics(jobId: string, containerType: ContainerType, containerId: string): [Metric]"),": Gets metrics for a network container emitted by an ingestion job.")),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("p",null,"The input and response types for the queries are as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ContainerType = TOTAL // Whole network\n    | GeographicalRegion // Everything inside a geographical region\n    | SubGeographicalRegion // Everything inside a sub-geographical region\n    | SubstationTotal // Everything inside and downstream of a substation\n    | Substation // Everything inside a substation\n    | FeederTotal // Everything inside and downstream of a feeder line\n    | Feeder // Everything inside a feeder line\n    | LvFeeder // Everything inside a contiguous LV network\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'IngestionJob = {\n    id: string, // UUID of the ingestion job\n    application: string, // Name of the ingestor application used\n    applicationVersion: string, // Version of the ingestor application used\n    source: string, // Short description of the source data (e.g. "ExampleEnergy 2024 HV/LV")\n    startTime: string // RFC 3339 timestamp of when the ingestor application started\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"JobSource = {\n    name: string, // Name of the data source. This will be unique within each ingestion job.\n    fileHash: string?, // Optional SHA-256 hash of the data source in hexadecimal\n    timestamp: string? // RFC 3339 timestamp of when the data source was exported\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Metric = {\n    name: string, // Name of the metric. This will be unique within each network container for each ingestion job.\n    value: double, // Value of the metric\n}\n")))}h.isMDXComponent=!0}}]);